#!/usr/bin/env bash


# 服务器、笔记本、WSL 共享的alias配置

[ $DotFileDebug -ne 0 ] && echo share .bash_aliases >&2

# 解决ubuntu18.0 无法用apt安装ripgrap (即rg)
# 参考: https://gist.github.com/kostaz/6e0cf1eee35a34cd6589ec15b58e682c
# 症状:
    # `sudo apt install ripgrep` 会如下报错
    # WARNING: apt does not have a stable CLI interface. Use with caution in scripts.

    # Reading package lists...
    # Building dependency tree...
    # Reading state information...

    # No apt package "ripgrep", but there is a snap with that name.
    # Try "snap install ripgrep"

    # E: Unable to locate package ripgrep
if [ "$(uname)" = "Linux" ]; then
    rg_install()
    {
        if [ "$(command -v apt)" = '' ]; then
            echo 'found no `apt`, please install `apt` first' >&2
        elif [ "$(command -v rg)" != '' ]; then
            echo 'rg already installed' >&2
        else
            local tmpfile=$(mktemp /tmp/install_ripgrep.XXXXXX)

            echo "\n> sudo apt install ripgrep"
            sudo apt install ripgrep 2>&1 | tee ${tmpfile}

            if [ "$(cat ${tmpfile} | grep 'E: Unable to locate package ripgrep')" != '' ]; then
                if [ "$(apt-cache policy | grep ripgrep)" = '' ]; then
                    echo "\n> sudo add-apt-repository -y ppa:x4121/ripgrep"
                    sudo add-apt-repository -y ppa:x4121/ripgrep
                fi
                echo "\n> sudo apt update"
                sudo apt update
                echo "\n> sudo apt install ripgrep"
                sudo apt install ripgrep
            fi
            rm ${tmpfile}
        fi
    }
fi


imgcurl() {
    curl "${@}" | imgcat
}

# ---------------------- hostname -------------------
# change hostname
hostname_change() {
    local new_hostname="$1"
    local old_hostname="$(hostname)"
    sudo hostnamectl set-hostname "${new_hostname}"
    echo "current hostname: "
    hostnamectl | head -n 1
    echo
    sudo sed -E -i "s/(\s)${old_hostname}(\s|$)/\1${new_hostname}\2/g" /etc/hosts
    if [ "$(cat /etc/hosts | grep -E "\s${new_hostname}(\s|$)")" = '' ]; then
        {
            echo "127.0.0.1 ${new_hostname}"
            cat /etc/hosts
        } | sudo tee /etc/hosts >/dev/null
    fi
    echo "current /etc/hosts:"
    cat /etc/hosts  | grep 127.0.0.1
}

# ---------------------- users ----------------------
# `gid` 列出所有group及其信息
# `gid 组名` 若返回非空则此组存在
gid () {
    if [ $# -eq 0 ]
    then
        getent group | awk -F '[:]' '{print $3, $1":"$2":"$4}' | sort -n
    else
        getent group $@
    fi
}

grp () {
    if [  "$1" = "add" ]; then
        local group="$1"
        sudo groupadd "$group"
    elif [ "$1" = "del" ]; then
        local group="$1"
        sudo groupdel "$group"
    elif [ "$1" = "addto" ]; then
        local user="$1"
        local group="$2"
        sudo usermod --append --groups "$group" "$user"
    elif [ "$1" = "delfrom" ]; then
        local user="$1"
        local group="$2"
        sudo gpasswd -d "$user" "$group"
    else
        echo 'grp: group management tool'
        echo '`grp add <group>` : add a new group'
        echo '`grp del <group>` : delete a group; this only works when the group contains no users'
        echo '`grp addto <user> <group>` : add a user to a group'
        echo '`grp delfrom <user> <group>` : remove a user from a group'
    fi
}


# ---------------- alias to resource ----------------
alias nvd='watch -n 10 nvidia-smi'  # 查GPU使用
alias gpu='watch -n 10 gpustat'     # 查看GPU使用，谁在用
alias gpujch='nvidia-who'            # 看用哪个进程在用显卡

# 用法
# `gpuid 0 python xxx.py` 现在暂时用GPU0运行 xxx.py
# `gpuid 0` 并不能使得接下来一直默认用GPU0运行各个程序
# gpuid()
# {
    # # local gpuids="$1"; shift
    # # eval CUDA_VISIBLE_DEVICES=$gpuids $@
    # local args=""
    # for i in "$@"; do
        # if [[ "$i" =~ ' ' ]]; then
            # local args="$args'$i' "
        # else
            # local args="$args$i "
        # fi
    # done
    # eval "CUDA_VISIBLE_DEVICES=${args}"
# }

space_args() {
    local name="$1"; shift
    local args=()
    for arg in "$@"; do
        if [[ "$arg" =~ ' ' ]] || [[ "$arg" =~ $'\t' ]] ||  [[ "$arg" =~ $'\n' ]]; then
            local tmp="${arg//'/'\\''}"
            args+=("'${tmp}'")
        else
            args+=("${arg}")
        fi
    done

    eval "$name"'=("$args[@]")'
}

gpuid() {
    local gpuid_setting="CUDA_VISIBLE_DEVICES=$1"; shift
    gpuid_args=()
    space_args gpuid_args "$@"
    eval "$gpuid_setting" "${gpuid_args[@]}"
    unset gpuid_args
}

# gpuid() {
    # local _gpuids="$1"; shift
    # "CUDA_VISIBLE_DEVICES=$_gpuids" "$@"
# }

# use no gpu i.e. cpu only
alias nogpu='CUDA_VISIBLE_DEVICES=-1 '

alias mem='free -h'  # 查内存使用
alias cpu='mpstat'   # 查看CPU使用率
alias yp-a='df -h' # 查看所有硬盘使用
alias yp='df -h' # 查看当前目录所在硬盘使用

alias cuda-v='nvcc -V'      # 查看cuda版本
alias cuda-vs='ls -l /usr/local/ | grep cuda'  # 查看所有cuda的安装目录

alias sys_xt='lsb_release -a'   # 查看操作系统版本
alias sys_ws='getconf LONG_BIT' # 查看系统位数
alias sys_nh='cat /proc/version' # 查看内核版本
alias sys_cpu_v='echo -n "logic cpu num:";  cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c' #  查看CPU信息（型号）
sys()
{
    echo -n "系统: "
    lsb_release -a  # 查看操作系统版本
    echo -n '系统架构：'
    uname -m
    echo -n "位数: "
    getconf LONG_BIT   # 查看系统位数
    echo -n  "内核: "
    cat /proc/version # 查看内核版本
    echo -n "CPU: "
    echo -n "logic cpu num:"
    cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c #  查看CPU信息（型号）
}


# 总核数 = 物理CPU个数 X 每颗物理CPU的核数
# 逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数
alias pcpu_n='cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l' # 物理cpu数
cpu_nh()    # 每个物理CPU的核数
{
    echo ${$(cat /proc/cpuinfo| grep "cpu cores"| uniq)//[^0-9]/}
}
alias lcpu_n='cat /proc/cpuinfo| grep "processor"| wc -l'   # 逻辑cpu数

cxc_n() # 超线程数目
{
    echo $((10#$(lcpu_n)/10#$(pcpu_n)/10#$(cpu_nh)))
}
cpu_n()
{
    echo -n "物理CPU数："; pcpu_n
    echo -n "每CPU核数：";cpu_nh
    echo -n "逻辑CPU数：";lcpu_n
    echo -n "超线程数："; cxc_n
}


alias size='du -ahxd0' # sl <dir_path>， 查看某个文件、文件夹的大小，<dir_path>缺省则为当前目录
# 数文件/文件夹个数
sl() {
    local targets=("$@")
    [ ${#targets[@]} -eq 0 ] && targets=(.)
    for i in "${targets[@]}"; do
        du -ahxd0 $i | read -r size line
        printf "%s\t" $size
        ls -d --color=always $line

        du -ahxd1 "$i" | sort -hk1 | while IFS=$'\t' read -r size line; do
            printf "%s\t    " $size
            ls -d --color=always $line
        done
    done | column -t -s $'\t'
}
# alias sl='python $share_script/sizelist.py' # sl <dir_path> ,查看某个目录及其下一级所有文件、文件夹的大小，<dir_path>缺省则为当前目录
# sl为size ls之意, <dir_path>缺省则为当前目录
# alias count='python $share_script/countfile.py'
# 列出 指定目录下子目录 含有某字符串的 文件/文件夹 的个数
# alias cl='python $share_script/countfile.py -lar'


cl() {
    if [[ $1 =~ ^(-h|--help)$ ]]; then
        cat <<EOF
Usage:
    cl -h|--help                      显示帮助
    cl [options] [dir=. [dir ...]]    列出每个dir下各个1~n级展开目录下的文件数, 会显示隐藏路径下的文件

Options:
    缺省一切参数     列出各个1级目录, 递归统计其下所有 文件和软连接,
    -f <文件类型>    <文件类型> 为以下一或多个字母连接而成
        F 默认       文件 软连接
        a            文件 软连接 文件夹
        f            文件
        d            文件夹
        l            软链接
    -L <深度n>       展开目录的深度, 0,1(默认),2,...
    -R               统计某个展开目录中文件个数时, [不]递归到其下所有文件
EOF
        return
    fi

    # argparse
    local expand_depth=1
    local no_recursive=0
    local find_type='F'

    while [ "${1:0:1}" = '-' ]; do
        if [[ "$1" =~ ^-L ]]; then
            if [ "$1" != '-L' ]; then
                if [ "${1:2:1}" = '=' ]; then
                    expand_depth="${1:3}"
                else
                    expand_depth="${1:2}"
                fi
                shift
            else
                shift
                ( [ "${1:0:1}" = '-' ] || [ $# -eq 0 ] ) && cl -h && return
                expand_depth="$1"
                shift
            fi
            [[ ! "$expand_depth" =~ ^[0-9]+$ ]] && cl -h && return
        elif [ "$1" = '-R' ]; then
            no_recursive=1
            shift
        elif [ "$1" = '-f' ]; then
            shift
            ( [ "${1:0:1}" = '-' ] || [ $# -eq 0 ] ) && cl -h && return
            find_type="$1"
            shift
        else
            cl -h && return
        fi
    done

    # declare expand_depth
    # declare no_recursive
    # declare find_type

    if [ $# -eq 0 ]; then
        local targets='.'
    else
        local targets=("$@")
    fi


    if [ "$find_type" = 'F' ]; then
        local args_type=(-type f -o -type l)
    elif [ "$find_type" = 'a' ]; then
        local args_type=(-type f -o -type l -o -type d)
    else
        local args_type=(-type ${find_type:0:1})
        for ((i=1; i<${#find_type}; i++)); do
            args_type+=(-o -type  ${find_type:$i:1})
        done
    fi

    __count_path()
    {
        local dir="$1"
        if [ $no_recursive -eq 1 ]; then
            echo -n $(find "${dir}" -maxdepth 1 -mindepth 1 "${args_type[@]}" | wc -l)
        else
            echo -n $(find "${dir}" "${args_type[@]}"  | wc -l)
        fi
    }

    local i=
    for i in "${targets[@]}"; do
        # [ ${#targets[@]} -gt 1 ] && [ $expand_depth -ge 1 ] && echo " \tnum"
        (
            __count_path "$i"
            echo -n "\t"
            ls -d --color=always $i

            # if [ $expand_depth -ge 1 ]; then
                local dir=
                find ${i} -maxdepth ${expand_depth} -mindepth 1 -type d | sort | while read dir; do
                    __count_path "${dir}"
                    echo -n "\t    "
                    ls -d --color=always $dir
                done | sort -t $'\t' -k 1 -n
            # fi
        )
    done | column -t -s $'\t'
}

# 计算目录下文件数目
count() {
    cl -L 0 "$@"
}

findname() # 按名字查找
{
    if [ $# -lt 2 ]
    then
        echo "Usage: fd <path> <name>"
    else
        local argvpath=$1; shift 1
        find $argvpath -name $* 2>&1 | grep -v "Permission denied"
    fi
}

# -------------------- 网络-------------------------
# open http server to share files
http-share() {
    if [[ "$1" =~ ^(-h|--help)$ ]]; then
        echo 'Usage:'
        echo '    http-share       : file-or-dir [file-or-dir ...]'
        return
    fi
    local share_port=8000
    local tempdir="$(mktemp -d)"
    [ ! -d "${tempdir}" ] && echo failed to creat tempdir ${tempdir} >&2 && return
    # cp -r "$@" "${tempdir}"
    # ys "$@" - "${tempdir}/archive.7z"
    zip -r  "${tempdir}/archive.zip" "$@"
    (
        cd "${tempdir}"
        echo
        echo -e "file website: \033[34mhttp://$(nw):${share_port}\033[0m"
        echo
        python3 -m http.server ${share_port}
    )
    rm -rf "${tempdir}"
}

# open ftp server to share the files under current dir
ftp-share() {
    if [[ "$1" =~ ^(-h|--help)$ ]]; then
        echo 'Usage:'
        echo '    ftp-share [<args>] : share the current dir, enable write and read by anonymous user'
        echo '<args>:'
        echo '    run `python3 -m pyftpdlib -h` for details'
        return
    fi
    if [[ "$(pip3 show pyftpdlib 2>&1)" =~ 'WARNING: Package\(s\) not found: pyftpdlib' ]]; then
        echo '> pip3 install pyftpdlib'
        pip3 install pyftpdlib
    fi
    if [[ "$(pip3 show pyftpdlib 2>&1)" =~ 'WARNING: Package\(s\) not found: pyftpdlib' ]]; then
        echo 'failed to `pip3 install pyftpdlib`' >&2
        return
    fi
    local share_port=2121
    echo -e "ftp: \033[34mftp://$(nw):${share_port}\033[0m"
    echo 'enabled anonymous login'
    echo
    python3 -m pyftpdlib -w -p ${share_port} "$@"
}

# ping <ip-or-domain> | na
# traceroute <ip-or-domain> | na
# 显示输出中ip的地理位置
nali()
{
    if [[ "$1" =~ '^help|-h|--help$' ]]; then
        command nali help | sed -E 's/(update.+)/\1\
  upgrade     upgrade nali to the newest version/g'
    elif [ "$1" = 'upgrade' ]; then
        (
        local tempdir="$(mktemp -d)"
        cd ${tempdir}
        echo "created temporary dir to save downloaded .gz file: ${tempdir}\n"

        if [ "$(uname)" = "Darwin" ]; then
            local system='darwin'
        else
            local system='linux'
        fi
        local version=$(curl -s https://github.com/zu1k/nali/releases/latest | sed -E 's/.*tag\/(.+)".*/\1/g')

        echo "Downloading nali-${system}-amd64-${version}.gz:"
        wget --no-check-certificate https://github.com/zu1k/nali/releases/download/${version}/nali-${system}-amd64-${version}.gz

        echo -n "\nDownloaded: " && command ls

        gzip -d nali-${system}-amd64-${version}.gz
        mv nali-${system}-amd64-${version} nali
        chmod +x ./nali

        if [ "$(uname)" = "Darwin" ]; then
            mv nali $macENV/local/bin
            echo "\ninstalled 'nali' to $macENV/local/bin"
        else
            mv nali $serverENV/local/bin
            echo "\ninstalled 'nali' to $serverENV/local/bin"
        fi

        rm -rf "${tempdir}"
        echo "\nremoved temporary dir ${tempdir}"

        echo "\nInstalled successfully: nali-${system}-amd64-${version}"
        )
    elif (( $# == 0 )) ; then
        (command nali "$@" | perl -pe 's/( \[.+?\]){2,}/\1/g; s/(((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3} \[.+?\]) *\(\1\)/\1/g') < /dev/stdin
        # echo
    else
        command nali "$@" | perl -pe 's/( \[.+?\]){2,}/\1/g; s/(((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3} \[.+?\]) *\(\1\)/\1/g'
        # echo
    fi
}

# 查看内网ip
nw() {
    if [ "$(uname)" = "Darwin" ]; then
        ipconfig getifaddr en0
    else
        hostname -I
    fi
}

# alias ww='curl ifconfig.me'
# 查看外网ip
ww()
{
    local wwip=`curl ifconfig.me` >/dev/null 2>&1
    echo $wwip
}

# 查看进程对应的端口号
jch2dk() {
    sudo lsof -i -P | awk NR==1
    for i in "$@"; do
        sudo lsof -i -P | awk '{ if ($2 == '"$i"') { print } }'
    done
    # netstat -natp | grep "$@"
}


# 查看端口
# _dk [<port1> [<port2> ... ]]
# 其中不写端口是查看所有端口的占用情况
_dk()
{
    if [ $# -eq 0 ]; then
        sudo lsof -Pn
    else
        local ports=
        local port_pattern=
        local i=
        for port in "$@"; do
            ports="$ports$port,"
            port_pattern="${port_pattern}${port}|"
        done
        ports=${ports:0:${#ports}-1}
        port_pattern="(${port_pattern:0:${#port_pattern}-1})"
        # eval sudo lsof -Pn -i:$ports
        eval "sudo lsof -Pn -i:$ports" | head -n 1
        eval "sudo lsof -Pn -i:$ports" | grep -E --color=always "${port_pattern}"
    fi
}
# strU8DiffLen () {
    # local bytlen oLang=$LANG oLcAll=$LC_ALL
    # LANG=C LC_ALL=C
    # bytlen=${#1}
    # LANG=$oLang LC_ALL=$oLcAll
    # return $(( bytlen - ${#1} ))
# }

# 查看占用某些端口的进程, 并输出端口信息、进程的信息，至少写一个端口
# _dk <port1> [<port2> ... ]
dk()
{
    if [ $# -eq 0 ]; then
        return
    fi

    local dk_return="$(_dk $@)"
    local title="$(echo "$dk_return"|head -n 1)"
    local content="$(echo "$dk_return"|sed '1d')"
    local title_short="$(echo "$title"    |perl -pe 's/^(\S+\s+){4}(\S+)(\s+\S+\s+\S+)/\2/g')"
    local content_short="$(echo "$content"|perl -pe 's/^(\S+\s+){4}(\S+)(\s+\S+\s+\S+)/\2/g')"
    local dk_short="$title_short"$'\n'"$content_short"

    local pids=($(echo "$content"|awk '{print $2}'))
    if [ ${#pids} -eq 0 ]; then
        return
    fi

    local jch_return=()
    local pid=
    for pid in "${pids[@]}"; do
        jch_return+=("$(jchpid "$pid" | sed -n '2p'|
            perl -pe 's/^((\S+\s+){3}\S+)((\s+\S+){4}\s*)([\S\s]{7}\S\s+\S+)(\s+)(.+)$/\1\5\n\e[2m\7\e[22m/g')" )
    done
    local jch_return=("$(jchpid "$pid"|head -n 1|
        perl -pe 's/^((\S+\s+){3}\S+)((\s+\S+){4}\s*)([\S\s]{7}\S\s+\S+)(\s+)(.+)$/\1\5\n\e[2m\7\e[22m/g')"
            "${jch_return[@]}")
    local i=

    local first_length=$(echo "$dk_short" | while  IFS=  read -r line ; do
        local line_without_red=$(cat -v <<< "$line" | sed -E "s/(\^\[\[01;31m\^\[\[K|\^\[\[m\^\[\[K)//g")
        local line_char_num=${#line_without_red}
        echo $line_char_num
    done | sort -n | tail -1)

    local i=0
    echo "$dk_short" | while  IFS=  read -r line ; do
        echo -n -E "$line"
        local line_without_red=$(cat -v <<< "$line" | sed -E "s/(\^\[\[01;31m\^\[\[K|\^\[\[m\^\[\[K)//g")
        local line_char_num=${#line_without_red}
        local j=
        for (( j = 0; j < $(($first_length - ${line_char_num})); j++ )); do
            echo -n ' '
        done
        echo -n ' '
        echo -n -E "${jch_return[@]:$i:1}"
        echo
        i=$(($i + 1))
    done | uniq
}

# 杀掉监听某个端口的进程
# dkd <一个端口>
kdk()
{
    kill -9 $(lsof -i:$1 | grep '(LISTEN)' | awk '{print $2}' | uniq)
}

# 测延迟
yc()
{
    if [ $# -ne 0 ]; then
        echo "测试访问延迟：$@"
        curl -s -w 'Testing Website Response Time for :%{url_effective}\n\nLookup Time:\t\t%{time_namelookup}\nConnect Time:\t\t%{time_connect}\nAppCon Time:\t\t%{time_appconnect}\nRedirect Time:\t\t%{time_redirect}\nPre-transfer Time:\t%{time_pretransfer}\nStart-transfer Time:\t%{time_starttransfer}\n\nTotal Time:\t\t%{time_total}\n' -o /dev/null $@
    else
        echo '延迟测试：'
        curl -s https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py | python -
    fi
}

# 查看路由表
alias lyb='netstat -nr'
# 修改静态路由
alias jtly='sv /etc/network/interfaces'


# 清理本地dns缓存
if [ "$(uname)" = "Darwin" ]; then
    alias dnsrm='sudo killall -HUP mDNSResponder'
else
    alias dnsrm='sudo /etc/init.d/nscd restart'
    # alias dnsrm='sudo /etc/init.d/dns-clean start'
fi

# 重启本地网络, 让/etc/network/interfaces 生效
alias network-restart='sudo /etc/init.d/networking restart'

# -------------------- 进程管理 --------------------
# 搜索进程
# alias jc='ps aux | awk 'NR==1'; ps aux | grep -v grep | grep'
jch()
{
    if [ $# -eq 0 ]; then
        echo 'Usgae: jc args_for_grep'
        return
    fi
    local title="`ps aux | awk NR==1`"
    local content="`ps aux | awk NR!=1 | grep -v grep | grep $*`"
    if [ "$content" != "" ]; then
        echo $title
        ps aux | awk NR!=1 | grep -v grep | grep -v 'ps aux' | grep -v 'awk NR!=1' | grep $*
    fi
}
# 查看对应教程的pid，jchpid <pid1> [<pid2> [ <pid3>...]]
alias jchpid='ps u -p'


# 按pid杀死进程
kpid()
{
    local x=
    for x in "$@"
    do
        kill -9 $x
    done
}
# 按jobs的号码杀掉进程
kjob()
{
    local x=
    for x in "$@"
    do
        kill %$x
    done
}

# --------------------- 软件 ----------------------

# sub(){
#     if [ -d /Applications/Sublime\ Text.app ]; then
#         # 本地是Mac，且有sublime
#         open -a "/Applications/Sublime Text.app" $*
#     else
#         # 本地非mac，或无sublime
#         echo "\"open sublime on mac client\""
#         sleep 0.1
#         dirs=""
#         for arg in $@; do
#             if [ -f $arg ]; then
#                 # echo "用笔记本上的sublime开文件 $arg"
#                 # 但文件走rsub
#                 rsub $arg
#                 n_file=1
#             elif [ -d $arg ]; then
#                 # echo "用笔记本上的sublime开文件夹: $arg"
#                 dirs="$dirs $(cd $arg; pwd)"
#             else
#                 echo no directory or file $arg
#             fi
#         done
#         if [ "$dirs" != "" ]; then
#             # 文件夹走sftp
#             # 以备iterm2抓取用户、服务器、文件夹路径，从而用远程的sublime sftp开
#             echo "user: $USER; hostname: `hostname`; path: '$dirs'"
#         fi
#     fi
# }

abspath(){
    echo $(cd $(dirname "$1") && pwd -P)/$(basename "$1")
}
# sub(){
    # if [ -d /Applications/Sublime\ Text.app ]; then
        # # 本地是Mac，且有sublime
        # open -a "/Applications/Sublime Text.app" $*
    # else
        # # 所有文件走sshfs，可以开文件夹和文件
        # dirs=""
        # for arg in $@; do
            # if [ -e $arg ]; then
                # path_arg=$(abspath $arg)
                # dirs="$dirs '$path_arg'"
            # else
                # echo not exist: $arg
            # fi
        # done
        # if [ "$dirs" != "" ]; then
            # echo  "local open app: sub; user: $USER; hostname: `hostname`; path: $dirs"
        # fi
    # fi
# }

# if [ "$(uname -o)" != "Darwin" ]; then
    # # 不是mac
    # open(){
        # dirs=""
        # for arg in $@; do
            # if [ -e $arg ]; then
                # path_arg=$(abspath $arg)
                # dirs="$dirs '$path_arg'"
            # else
                # echo not exist: $arg
            # fi
        # done
        # if [ "$dirs" != "" ]; then
            # echo  "local open app: open; user: $USER; hostname: `hostname`; path: $dirs"
        # fi
    # }
# fi

my_open() {
    local app="$1"
    shift
    local dirs=
    local arg
    for arg in $@; do
        if [ -e $arg ]; then
            local path_arg=$(abspath $arg)
            dirs="$dirs; $path_arg"
        else
            echo not exist: $arg
        fi
    done
    # 去掉dirs字符串开头的'; '
    if [ "${dirs:0:2}" = "; " ]; then
        dirs=${dirs:2}
    fi
    if [ "$dirs" != '' ]; then
        echo 'remote open: '"$app"'; '"$USER"'; '"`hostname`"'; '"$dirs"
    fi
}

if [ "$(uname)" != "Darwin" ]; then
    # 不是mac
    if ! [ -x "`which code`" ] && ! [ -x "`which code-insiders`" ]  ; then
        # 没有code命令（即在服务器上，且目前不是用vscode远程登录）
        alias code='my_open code'
    fi
    alias open='my_open open'
    alias sub='my_open sub'
else
    if [ -d /Applications/Sublime\ Text.app ]; then
        # 本地是Mac，且有sublime
        alias sub='open -a "/Applications/Sublime Text.app"'
    fi
fi


server_port=8304 # 【远程nc端口】

rsubl(){
    local dirs=""
    local arg
    for arg in $@; do
        if [ -e $arg ]; then
            local path_arg=$(abspath $arg)
            dirs="$dirs; $path_arg"
        else
            echo not exist: $arg
        fi
    done
    if [ "${dirs:0:2}" = "; " ]; then
        dirs=${dirs:2}
    fi
    if [ "$dirs" != "" ]; then
        (echo "sub; $USER; `hostname`; $dirs" | nc localhost $server_port  & )   > /dev/null
    fi
}

ropen(){
    local dirs=""
    local arg
    for arg in $@; do
        if [ -e $arg ]; then
            local path_arg=$(abspath $arg)
            dirs="$dirs; $path_arg"
        else
            echo not exist: $arg
        fi
    done
    if [ "${dirs:0:2}" = "; " ]; then
        dirs=${dirs:2}
    fi
    if [ "$dirs" != "" ]; then
        (echo "open; $USER; `hostname`; $dirs" | nc localhost $server_port & )   > /dev/null
    fi
}

# ------------------------ 文本编辑器 ----------------------

# VScode
# 当有 vscode-insiders 时，有 `code-insiders` 命令
# 当有 vscode 时，有 `code` 命令
# 当有 vscode-insiders 而无 vscode 时，将 `code-insiders` 命令 alias 为 `code`
if ( ! [ -x "`which code`" ] ) && [ -x "`which code-insiders`" ]; then
    alias code='code-insiders'
fi

_code-remote() {
    local hostname=$(echo $1 | awk -F : '{print $1}')
    local abspath_=$(echo $1 | awk -F : '{print $2}')
    local has_file=$(ssh $hostname "[ -f '$abspath_' ] && echo true")
    local has_dir=$(ssh $hostname "[ -d '$abspath_' ] && echo true")
    if [ "$has_file" = true ]; then
        code --file-uri vscode-remote://ssh-remote+${hostname}${abspath_}
    elif [ "$has_dir" = true ]; then
        code --folder-uri vscode-remote://ssh-remote+${hostname}${abspath_}
    else
        echo "$hostname:$abspath_ not exists"
    fi
}
co(){
    if [[ "$1" =~ ':' ]]; then
        _code-remote "$@"
    else
        code "$@"
    fi
}

if ! [ "$(uname)" = "Darwin" ]; then
    # 当vscode远程连接无法正常使用时，则运行之，以杀死所有vscode(-insiders)进程
    alias code-kill='pgrep -f "vscode" | xargs kill'
fi

# 设置vim
if [ -x /usr/bin/vim.gnome ]; then
    # 更换vim-gnome, 以支持clipboard
    alias vim='/usr/bin/vim.gnome'
fi

# 设置nvim
# if [ "$(uname)" != "Darwin" ] && [ "$(command -v nvim)" = '' ]; then
    # alias nvim="$serverENV/app/nvim.appimage"
    # # if [ -x $serverENV/app/nvim/usr/bin/nvim ]; then
    # # # 有的linux系统，没有fuse，故无法执行此镜像（但mac可以执行） `# alias nvim=$serverENV/local/bin/nvim.appimage`
        # # export PATH=$serverENV/app/nvim/usr/bin/:$PATH
        # # # alias nvim=$serverENV/nvim/usr/bin/nvim
    # # fi
# fi
# mac上用`brew install newvim` （neovim内核）并 `pip install neovim`（python支持）
# 安装完成后自带nvim命令

# 让sudo vim 能用nvim
# 设置默认编辑器
# if ( [ -x "`which code-insiders`" ] && [ "`which code-insiders`" != '/usr/bin/code' ] ) || \
   # ( [ -x "`which code`" ] && [ "`which code`" != '/usr/bin/code' ] ) ; then
    # alias default_editor='code'
if [ -x "$(which nvim)" ]; then
    if [ -x "$(which python)" ]; then
        alias sv="sudo PATH=$(dirname $(which python)):\$PATH $(which nvim)"
    else
        alias sv="sudo $(which nvim)"
    fi
    alias default_editor=nvim
elif [ -x "$(which vim)" ]; then
    if [ -x "$(which python)" ]; then
        alias sv="sudo PATH=$(dirname $(which python)):\$PATH $(which vim)"
    else
        alias sv="sudo $(which vim)"
    fi
    alias default_editor=vim
fi

# 给nvim, vim设置conda python环境
if [ -d "$(which -a python | grep conda | head -n 1 | sed -E 's/\/python.*//')" ] && [ -x "$(which nvim)" ]; then
    alias nvim='PATH=$(which -a python | grep conda | head -n 1 | xargs dirname):$PATH nvim'
fi

if [ -d "$(which -a python | grep conda | head -n 1 | sed -E 's/\/python.*//')" ] && [ -x "$(which vim)" ]; then
    alias vim='PATH=$(which -a python | grep conda | head -n 1 | xargs dirname):$PATH vim'
fi

alias nvi=nvim
alias nv=nvim
alias v=nvim
alias vi=vim

# --------------- alias dotfile ----------------------
se=~/.shell_config/.env;      sse=$share_shell_config/.env
si=~/.shell_config/.login;
so=~/.shell_config/.logout;
sa=~/.shell_config/.aliases;  ssa=$share_shell_config/.aliases

be=~/.bash_env
bp=~/.bash_profile
br=~/.bashrc;                      sbr=$share_shell_config/.bashrc
bo=~/.bash_logout

ze=~/.zshenv
zp=~/.zprofile
zr=~/.zshrc;                       szr=$share_shell_config/.zshrc
zo=~/.zlogout

# others
alias vtmux='default_editor ~/.tmux.conf'
alias stmux='tmux source-file ~/.tmux.conf'
alias vv='default_editor ~/.vimrc'           # vim 免source，重新开vim即生效
alias vvp='default_editor ~/.vimrc.bundles'      # vim 的插件
alias ivp="v -u ~/.vimrc.bundles +'PlugInstall --sync' +qa"  # 按照.vimrc.bundles下载安装之前没有的vim的插件
alias uvp="v -u ~/.vimrc.bundles +'PlugInstall --sync' +'PlugUpdate' +qa"  # 按照.vimrc.bundles下载安装之前没有的vim的插件，并升级已有插件
alias make_ycm='$HOME/.vim/plugged/YouCompleteMe/install.sh' # 编译YouCompleteMe
fix_ycm() {
    # 参考：https://www.lizenghai.com/archives/22681.html
    ycm_path="$HOME/.vim/plugged/YouCompleteMe"
    mkdir -p $ycm_path/third_party/go/src/golang.org/x
    cd $ycm_path/third_party/go/src/golang.org/x
    git clone https://github.com/golang/tools.git

    cd $ycm_path/third_party/ycmd/third_party/go/src/golang.org/x
    git clone https://github.com/golang/tools.git

    cd $ycm_path
    git submodule update --init --recursive

    $ycm_path/install.sh
}


alias vgit='default_editor ~/.gitconfig'

fix_golang()
{
    # 法一：https://www.lizenghai.com/archives/22681.html
    local ycm_path="$HOME/.vim/plugged/YouCompleteMe"
    mkdir -p $ycm_path/third_party/go/src/golang.org/x
    cd $ycm_path/third_party/go/src/golang.org/x
    git clone https://github.com/golang/tools.git

    cd $ycm_path/third_party/ycmd/third_party/go/src/golang.org/x
    git clone https://github.com/golang/tools.git

    cd $ycm_path
    git submodule update --init --recursive

    $ycm_path/install.sh
}

fix_zsh_history()
{
    mv ~/.zsh_history ~/.zsh_history_bad
    strings ~/.zsh_history_bad > ~/.zsh_history
    fc -R ~/.zsh_history
    rm ~/.zsh_history_bad
}

# ---------------- 环境显示 -----------------------
# 显示路径，换行分隔，例如 `showpa PATH`， `showpa <任何一环境变量>`
showpa()
{
    eval "echo \$$1 | sed 's/:/\'$'\n/g'"
}
# 添加路径，例如 `addpa PATH <新路径>`
addpa()
{
    eval "export $1=$2:\$$1"
}
# 删除路径，例如 `addpa PATH <待删除路径>` ，若待删除路径不在$PATH中，则不对$PATH做更改
rmpa()
{
    newpath=$(eval "echo \$$1 | sed 's:$2\:::g' | sed 's:\:$2::g'")
    # 路径有'/'，用'/'分隔会冲突，改用':'分隔
    eval "export $1=$newpath"
}

# ssh
alias vssh='default_editor ~/.ssh/config';
alias vhost='default_editor /etc/hosts' # 系统文件，个人账号用sub看不了
alias sendkey='ssh-copy-id -o PreferredAuthentications=password -i'     # 发送公钥
# sendkey [<公钥或对应私钥的路径>, 默认是~/.ssh/id_rsa[.pub]] {<用户>@<服务器>|<服务器alias>}

# ssh自动重连
if [ "$(command -v autossh)" != '' ]; then
    ssh() {
        # local autossh_port=9090
        # while true; do
            # [ "$(lsof -i:${autossh_port})" = '' ] && break
            # autossh_port=$((${autossh_port} + 1))
        # done
        while true; do
            local autossh_port="$(shuf -i 2000-65000 -n 1)" # generate random port in [2000,65000]
            [ "$(lsof -i:${autossh_port})" = '' ] && break
        done
        # echo "autossh -M ${autossh_port} \"$@\""
        autossh -M ${autossh_port} "$@"
    }
fi
# ---------------- alias cp、scp ----------------

# 拷贝、传输一个文件或文件夹（及其下各级所有文件），包括隐藏文件
alias cp="cp -r"
alias scp="scp -r"



rdiff()
{
    if [ $# -ne 2 ]; then
        echo 'diff dir or file with dry-run rsync:'
        echo '    `rdiff <file1> <file2>`'
        echo '    `rdiff <dir1> <dir2>`'
        return
    fi
    local source_path="$1"
    local dest_path="$2"
    [ ! -e ${source_path} ] && echo "no file or dir: ${source_path}" && return
    [ ! -e ${dest_path} ] && echo "no file or dir: ${dest_path}" && return
    [ -d ${source_path} ] && local source_path="${source_path}/"

    echo rsync -rvnc --delete "$source_path" "$dest_path"
    rsync -rvnc --delete "$source_path" "$dest_path"
}

# 自动端点续传，传送失败后隔180秒自动重新连接
# autots（alias）会被下面的autots函数覆盖，用来使得下面的autots函数能够和rsync一样自动补全远程目录
# [ -n "$ZSH_NAME" ] && [[ -o interactive ]] && compdef _rsync autots
autots() {
    local retry_time=180 # second
    while [ 1 ]
    do
        #  -e 'ssh -o ClearAllForwardings=yes' 清空端口转发;
        rsync -aHhvzP -e 'ssh -o ClearAllForwardings=yes' $*
        # command 调用系统的 rsync 命令，避免递归调用rsync
        if [ "$?" = "0" ] ; then
            echo "rsync completed normally"
            break
        else
            echo "Rsync failure. Backing off and retrying in $retry_time seconds..."
            sleep $retry_time
        fi
    done
}


# rsync 封装多种参数，但不支持断点续传; ts能够和rsync一样自动补全远程目录
#  -e 'ssh -o ClearAllForwardings=yes' 清空端口转发;
alias ts='rsync -aHhvz -e '\''ssh -o ClearAllForwardings=yes'\'' --progress'

# 下载到Downloads
# [ -n "$ZSH_NAME" ] && [[ -o interactive ]] && compdef _rsync download
download()
{
    local download_path="$HOME/Downloads"
    if [ -d $download_path ]; then
        rsync -aHhvz --progress $@ $download_path
    else
        echo "no dir $download_path; did not start downloading" >&2
    fi
}

# `cp 目录/.`   拷贝一个目录下所有文件，目录自身不拷，拷隐藏文件
# cp_under 一个或多个源目录 目标目录
cp_under()
{
    local sourcepaths=${*:1:$#-1}
    local targetpath=${*:$#:1}
    local x=
    for x in $sourcepaths
    do
        cp $x/. $targetpath
    done

}

# `cp 目录/*`   拷贝一个目录下所有文件，目录自身不拷贝，不拷隐藏文件
# cp_under_vis 一个或多个源目录 目标目录
cp_under_vis()
{
    local sourcepaths=${*:1:$#-1}
    local targetpath=${*:$#:1}
    local x
    for x in $sourcepaths
    do
        cp $x/* $targetpath
    done
}

# -------------------- alias to ls ---------------------
alias tree='tree -N'  # -N 原编码输出，以避免在mac上中文路径出现乱码

#  -F  文件夹结尾加/
#  -C  多列
#  -A  显示隐藏文件
#  -l  use a long listing format, 即显示所有文件信息，一个文件一行
#  -G  in a long listing, don't print group names
#  -h  文件大用kMG单位

# 若当前是zsh 且为交互模式
# if [ -n "$ZSH_NAME" ] && [[ -o interactive ]]; then
    # ls_list() { :; }
    # compdef  _ls ls_list
    # alias ll='ls_list'
    # alias la='ls_list'
    # alias l='ls_list'
# fi

list_less_line_num=50

# 显(xxx)隐(.xxx) 文件(xxx)文件夹(xxx/) 用户名 大小 创建日期 大小用GMk格式
alias llc='ls -AlFh --sort=version --color=always'
ll() {
    local line_num=$(llc "$@" | wc -l)
    if [ $line_num -gt $list_less_line_num ]; then
        # 当超过 $list_less_line_num 行时, 则输出到less
        {
            echo "#line = $line_num"
            llc "$@"
        } | less -R
    else
        llc "$@"
    fi
}

# 显(xxx)隐(.xxx) 文件与文件夹不区分(xxx)
alias lac='ls -CAF  --sort=version --color=always'
la() {
    local line_num=$(lac "$@" | wc -l)
    if [ $line_num -gt $list_less_line_num ]; then
        {
            echo "#line = $line_num"
            lac "$@"
        } | less -R
    else
        lac "$@"
    fi
}

# 显 文件(xxx)文件夹(xxx/)
alias lc='ls -CF   --sort=version --color=always'
l() {
    local line_num=$(lc "$@" | wc -l)
    if [ $line_num -gt $list_less_line_num ]; then
        {
            echo "#line = $line_num"
            lc "$@"
        } | less -R
    else
        lc "$@"
    fi
}

# safe remove
# sr file(s) or dir(s)
# mv to $my/trash/
# if the file/dir name conflicts with those in trash/, add time prefix on it
# support file/dir name conatins spaces and non-ascii chars
if [ "$(uname)" = "Darwin" ]; then
# mac
    trash=~/.Trash
else
# linux
    trash=$my/trash
fi

srm()
{
    if ! [ -d $trash ]; then
        echo $trash not existes, now made one
        mkdir $trash -p
    fi

    local i=
    for i in $*; do
        local base="$(basename $i)"
        if [ -e "$trash/$base" ] || [ -L "$trash/$base" ]; then
            local suffix=$(date "+%Y-%m-%d-%H:%M:%S")
            mv "$i" "$trash/$base.$suffix"
        else
            mv "$i" "$trash"
        fi
    done
}
srm-clean()
{
    if [ -d "$trash" ] && [ "$trash" != '' ] && [ "$trash" != '/' ] && [ "$trash" != './' ] && [ "$trash" != '.' ]; then
        local answer=$(bash -c "read  -n 1 -p 'irrevertabley clean $trash ? [Y|N]' c; echo \$c"); echo
        if [ "$answer" = 'Y' ] || [ "$answer" = 'y' ]; then
            rm -rf $trash/*
            rm -rf $trash/.*
        fi
    else
        echo "trash dir not exists: $trash"
    fi
}
# 安全清空目录，包括隐藏文件（夹）
srm_under()
{
    local x=
    for x in $*
    do
        srm $x/{*,.[!.]*}
    done
}
# 直接清空目录，包括隐藏文件（夹）
rm_under()
{
    local x=
    for x in $*
    do
        if [ -n "$ZSH_VERSION" ]; then  # zsh 下
            rm $x/{*,.*} -rf
        else
        # elif [ -n "$BASH_VERSION" ]; then # bash 下
            rm $x/{*,.[!.]*} -rf
        fi
    done
}

alias md='mkdir'
alias g='grep'
alias lk='ln -s'
alias lkf='ln -sfT'
# `lkf 被链接的路径 链接文件的路径` : 链接覆盖已有文件
#  `链接文件的路径` 是链接文件本身的路径, 不可是其所在dir的路径
#  若`链接文件的路径` 已有文件或链接, 则覆盖之
#  若`链接文件的路径` 已有文件夹, 则无法覆盖之


# lk <原身路径：可是文件、文件夹> [ <链接路径与名称> 默认是 . ]
# 创建软连接
alias ..='cd ../'
c()
{
    if [ $# = 0 ]; then
        if [ "$(uname)" = "Darwin" ]; then
            cd "$HOME/Desktop"
        else
            cd $my
        fi
    else
        cd "$@"
    fi
}
# 授权bash文件可执行
alias kzx='chmod +x'  # kzx 文件名： 设为可执行
alias bkzx='chmod -x' # bkzx 文件名：设为不可执行
# 改所有者：own <用户名>(:<组名>) 文件名
alias own='chown -R' # -R表示递归，即文件夹下诸物皆然

# -------------------------------------------------------------------------
# 压缩软件
# 7z压缩
ys()
{
    # help
    if [ "$1" = '-h' ] || [ "$1" = '--help' ]; then
        cat <<EOF
Usage:
    ys [<options>] 文件(夹) [- <压缩文件名>[.7z]]                            : <压缩文件名> 默认为 被压缩的文件(夹)名
    ys [<options>] 文件(夹)  文件(夹) [文件(夹)  ...] [- <压缩文件名>[.7z]]  : <压缩文件名> 默认为"archive"
    ys -h|--help                                                             : 显示帮助

Options:
    -p     : 加此参数后,
                若一个待压缩的文件(夹)若是当前向下的相对路径, 则将其中间的文件夹也压缩 (但不压缩那些文件夹下的所有文件)
                若一个待压缩的文件(夹)若是当前向上的相对路径, 或是绝对路径, 则仅压缩\$(bassnmae 待压缩的文件(夹))
             若不加此参数, 则任何时候仅压缩\$(bassnmae 待压缩的文件(夹))

说明:
    压缩文件重名时, 自动给文件名追加序号
EOF
        return
    fi

    # argpars
    local opt_with_path=0
    while true; do
        if [ "${1:0:1}" != '-' ]; then
            break
        elif [ "$1" = '-p' ]; then
            opt_with_path=1
            shift
        else
            ys -h
            return
        fi
    done

    # file parse
    if [ $# -ge 3 ] && [ '-' = "${@:`expr $# - 1`:1}" ]; then
        local filehead=`echo ${@:$#} | sed -E 's/.7z$//g'`
        local to_be_compressed=("${@:1:`expr $# - 2`}")
    elif [ $# -eq 1 ]; then
        local filehead=`basename $1 | sed -E 's/.7z$//g'`
        local to_be_compressed=("$1")
    else
        local filehead='archive'
        local to_be_compressed=("$@")
    fi

    if [ ${#to_be_compressed[@]} -eq 0 ]; then
        echo 'no file or diir to be compress' >&2
        return
    fi

    # append id after filehead for compressed file, when it has same name with other files/dirs
    local filehead_final="${filehead}"
    local file_id=0
    while [ -e "${filehead_final}.7z" ]; do
        local file_id=$(($file_id + 1))
        local filehead_final="${filehead}-${file_id}"
    done

    # check files to compress exist
    local not_found=0
    local i=
    for i in "${to_be_compressed[@]}"; do
        if [ ! -e "$i" ]; then
            echo "file or dir not exist: $i" >&2
            local not_found=1
        fi
    done
    [ $not_found -eq 1 ] && return

    # get abspath of files to compress
    local to_be_compressed_abs_path=()
    local i=
    for i in "${to_be_compressed[@]}"; do
        to_be_compressed_abs_path+=("$(abspath $i)")
    done

    # check abspaths of files to compress exist
    local not_found=0
    local i=
    for i in "${to_be_compressed_abs_path[@]}"; do
        if [ ! -e "$i" ]; then
            echo "file or dir not exist: $i" >&2
            local not_found=1
        fi
    done
    [ $not_found -eq 1 ] && return

    # 7z compress
    if [ "$opt_with_path" = 1 ]; then
        7z a ${filehead_final}.7z "${to_be_compressed[@]}"
    else
        7z a ${filehead_final}.7z "${to_be_compressed_abs_path[@]}"
    fi
}

# 7z解压
jy()
{
    if [ "$1" = '-h' ] || [ "$1" = '--help' ] || [ "$1" = 'help' ]; then
        echo 'Usage:'
        echo '    jy7z xxx.扩展名 [xxx.扩展名 ...] [- 目标目录(缺省为.)]'
        echo '    解压到`目标目录/xxx_extract`'
    else
        local file7z_list=()
        # local target_jieya_path_list=()
        while [ $# -ne 0 ]; do
            local file7z="$1"; shift 1
            if [ "$1" = '-' ]; then
                shift
                if [ $# -ne 0 ]; then
                    local target_jieya_path="$1"
                    shift
                fi
            else
                local target_jieya_path=.
            fi
            file7z_list+=("$file7z")
            # target_jieya_path_list+=("$target_jieya_path")
        done
        # local OLD_IFS=$IFS
        # IFS='.'
        # local tmp=($(echo "$file7z"))
        # IFS=$OLD_IFS
        # local filehead="${tmp[1]}"

        for (( i = 0; i < ${#file7z_list[@]}; i++ )); do
            local file7z=${file7z_list[@]:$i:1}
            local filename="${file7z}_extract"
            # local target_jieya_path=${target_jieya_path_list[@]:$i:1}
            local target_file="${target_jieya_path}/$(basename ${filename})"

            echo "discompact: $file7z -> $target_file"
            # local filehead=`echo $file7z | sed -E 's/.7z$//g'`
            # `7z x`一次只能解压一个文件

            eval "7z x ${file7z} -o${target_file}"
        done
    fi
}

# 通用解压
# alias jy='dtrx'
# 用法：
#     cd到解压路径
#     jy 压缩文件的路径（可以多个）
#     则自动将其解压到同名文件夹

# 更换默认shell
setsh()
{
    which $1  && chsh -s `which $1`
}
# -------------- 删除mac特有隐藏文件 --------------
# 删除 .DS_store 和 ._* 文件
# alias macdot_clean='find . \( -type f \( -name "._*" \) -o \( -name ".DS_Store" \) \) -delete'

# 删除 .DS_store 和 ._* 文件
# macdotrm ：删除当前目录下的这些文件
# macdotrm -r ：删除当前目录及其各级子目录下的这些文件
macdotrm()
{
    if [ "$1" = "-r" ]; then
        find . \( -type f \( -name "._*" \) -o \( -name ".DS_Store" \) \) -delete
    else
        rm -f ._*
        rm -f .DS_Store
    fi
    rm -rf __MACOSX
}


# ----------------- alias to pip ---------------
alias pip='pip --default-timeout=100'  # 避免报错 Read timed out.
pipreq()
{
    if [ $# -eq 1 ]; then
        local requirements_file="requirements.txt"
    elif [ $# -eq 2 ]; then
        local requirements_file="$2"
    fi

    if [ "$1" = 'install' ]; then
        pip install -r "$requirements_file"
    elif [ "$1" = 'save' ]; then
        pip freeze > "$requirements_file"
    else
        echo 'Usage:'
        echo '`pipreq install`   pip install requirements'
        echo '`pipreq save`      pip save to requirements'
    fi
}

# ---------------- alias to conda --------------
# 清华tuna源，官网https://mirrors.tuna.tsinghua.edu.cn/news/#oh-my-tuna
# # 国内默认使用tuna，装包会快很多
tuna()
{
    if [ "$1" = '--global' ]; then
        python $share_app_config/oh-my-tuna.py --global
    elif [ "$1" = 'install' ] || [ "$1" = 'update' ] ; then
        wget https://tuna.moe/oh-my-tuna/oh-my-tuna.py -O $share_app_config/oh-my-tuna.py --no-check-certificate
    elif [ "$1" = '-h' ] ||  [ "$1" = '--help' ] ||  [ "$1" = 'help' ] ; then
        echo "-------------------------------------------------------------------------"
        echo '                         help for the alias `tuna`'
        echo "tuna [ install | update]  : download the newest oh-my-tuna from \n      https://tuna.moe/oh-my-tuna/oh-my-tuna.py"
        echo "tuna [ help | -h | --help ] : for help"
        echo "tuna : apply tuna for the one user yourself"
        echo "sudo tuna --global : apply tuna for the all users"
        echo "tuna [arguments] : [arguments] follows oh-my-tuna.py"
        echo "-------------------------------------------------------------------------"
        python $share_app_config/oh-my-tuna.py -h
    else
        python $share_app_config/oh-my-tuna.py $*
    fi
}

#  ce: conda environment
alias ceact='conda activate'
alias cedea='conda deactivate'
alias cels='conda info -e' # 列出conda的环境
cenew() # enew 环境名字 python的版本  其他参数
{
    conda create -n $1 python=$2 ${@:3:$#}
}
cecp() # ecp 源环境名字 新环境名字
{
    conda create -n $2 --clone $1
}
cerm() # erm 环境的名字
{
    conda remove -n $1 --all
}

# ----------------- python虚拟环境 ------------------

venew()
{
    echo 'going to create a new virtualenv and activate it'
    if ! [ -x "$(command -v virtualenv)" ]; then
        echo 'You have no command "virtualenv"'
        local answer=$(bash -c "read  -n 1 -p 'Run \"pip install virtualenv\" to install it? [Y|N] ' c; echo \$c"); echo
        if [ "$answer" = 'Y' ] || [ "$answer" = 'y' ]; then
            if [[ "$(whereis pip)" =~ (^| )/usr/bin/pip$ ]]; then
                sudo pip install virtualenv
            else
                pip install virtualenv
            fi
        else
            echo "Install virtualenv before re-running me."
            return
        fi
    fi
    local version=$(bash -c "read -p 'python version (default \"3\")? ' c; echo \$c"); echo
    if [ "$version" = '' ]; then
        local version='3'
    fi
    local envdir=$(bash -c "read -p 'env dir name (default \"venv\")? ' c; echo \$c"); echo
    if [ "$envdir" = '' ]; then
        local envdir='venv'
    fi
    local ve_version=$(virtualenv --version | sed -E 's/(^|^.* )(([0-9]+\.)+([0-9]+))( .*$|$)/\2/g' | sed -E 's/^([0-9]+)\..*/\1/g') # 大版本
    if [ $ve_version -ge 20 ]; then
        virtualenv -p python$version $envdir
    else
        virtualenv --no-site-packages -p python$version $envdir
    fi   && \
    source venv/bin/activate $envdir
}

veact() {
    local venvpath='venv'
    if [ $# = 1 ]; then
        local venvpath="$1"
    fi
    source "${venvpath}/bin/activate"
}
# alias veact='source venv/bin/activate'
alias vedea='deactivate'

# ---------------- alias to python ------------------
alias py='python'
alias py3='python3'
alias py2='python2'
alias ipy='ipython'
alias nb='jupyter notebook' # open local jupyter notebook, it will automatically call safari to open the webpage

# tb [装event文件的目录(默认为.)], 不能是event，可以是其下一级或多级含有event的目录
# tb 实验名: 装event文件的目录 实验名: 装event文件的目录 实验名: 装event文件的目录 ...
tb()
{
    if [[ "$1" =~ "(--help|-h|help)" ]]; then
        echo 'tb [<tag1>:] <dir1> [<tag2>:<dir2>] [<dir3>]'
        echo '    default dir=.'
        echo '    default tag=<dir>'
        return
    fi

    i=1
    local dir_paths
    declare -a dir_paths
    while [ $# -ne 0 ]; do
        if [[ "$1" =~ "^-"  ]]; then
            break
        else
            if [[ "$1" =~ ':$' ]]; then
                local dir_path="$1$2"
                shift
            elif [[ "$1" =~ ':' ]]; then
                local dir_path="$1"
            else
                # local tag="${1//\//∕}"
                # local tag="${tag//:/∶}"
                local dir_path="${1}:$1"
                i=$(($i + 1))
            fi
            dir_paths=("${dir_paths[@]}" "$dir_path")
            shift
        fi
    done

 # declare -p dir_paths

    if [ ${#dir_paths} -eq 0 ]; then
        local dir_arg='--logdir=.'
    # elif [ ${#dir_paths} -eq 1 ]; then
        # local dir_arg="--logdir=${dir_paths[1]}"
    else
        # dir_arg='--logdir_spec='
        dir_arg='--logdir_spec='
        local i
        for i in "${dir_paths[@]}"; do
            dir_arg="${dir_arg}${i},"
        done
        dir_arg="${dir_arg:0:-1}"
    fi

    echo "tensorboard $dir_arg $@"
    tensorboard $dir_arg $@
}
# -----------------  alias to tmux ------------------
# list all session of tmux session
alias tl='tmux ls'
# rename a tmux session: tmv <current-session-name> <new-session-name>
alias tmv='tmux rename-session -t'
# kill a tmux session
alias tk='tmux kill-session -t'
# kill all tmux sessions i.e. kill the tmux server
tka()
{
    local answer=$(bash -c "read  -n 1 -p 'Do you want to kill the tmux server? [Y|N]' c; echo \$c")
    echo
    if [ "$answer" = "y" ] || [  "$answer" = "Y"  ]; then
        tmux kill-server
        echo 'killed'
    else
        echo "didn't kill"
    fi
}




#              命令   (i)tm                      (i)tm 已有session名    (i)tm 新session名
# 无tmux session 时   创建名为的default的session    --                   创建session
# 有tmux session 时   attach最近的session         attach该session       创建session
# itm:与iterm2关联的tmux
# tm：不关联iterm2的tmux

# if [ -n "$ZSH_NAME" ] && [[ -o interactive ]]; then
    # tmux_itm() {   :;    }
    # compdef _tmux tmux_itm
    # alias itm='tmux_itm -CC attach -t'
# fi

itm() {
    if [ "$(alias itm 2> /dev/null)" != '' ]; then
        for i in {1..3}; do shift; done
    fi
    if [ $# = 0 ]; then
        tmux -CC attach || tmux -CC new -s default
    else
        local session="$1"
        tmux -CC attach -t "${session}" || tmux -CC new -s "${session}"
    fi
}


# if [ -n "$ZSH_NAME" ] && [[ -o interactive ]]; then
    # tmux_tm() {   :;    }
    # compdef _tmux tmux_tm
    # alias tm='tmux_tm attach -t'
# fi

tm() {
    if [ "$(alias tm 2> /dev/null)" != '' ]; then
        for i in {1..2}; do shift; done
    fi
    if [ $# = 0 ]; then
        tmux attach || tmux new -s default
    else
        local session=$1
        tmux attach -t ${session} || tmux new -s ${session}
    fi
}

# -------------------------------------------------------------------------

# vnc server 桌面转发
vncs(){
    if [ $# -eq 0 ] || [ "$1" = "start" ] ; then
        vncserver :1 -geometry 1366x768
    elif [ "$1" = "stop" ]; then
        vncserver -kill :1
    elif [ "$1" = "restart" ]; then
        vncserver -kill :1
        vncserver :1 -geometry 1366x768
    elif [ "$1" = "passwd" ]; then
        vncpasswd
    elif [ "$1" = "config" ]; then
        default_editor ~/.vnc/xstartup
    elif [ "$1" = "help" ]; then
        echo 'Usage: vnc [ start(default)) | stop | restart | passwd | config | help ]'
    else
        echo 'Usage: vnc [ start(default)) | stop | restart | passwd | config | help ]'
    fi
}

# vnc viewer
# 用法：vnc 服务器别名
alias vncv='ssh -L 5901:127.0.0.1:5901 -C -N'
# -C 压缩所有数据；  -N 只转发端口 不能在远程终端下执行命令

# -------------------------------------------------------------------------
alias wgetc='wget -c -t 0'
# '-C'断点续传，' -t 0' 无限次断开次续传，'-T 900' 表示900秒(缺省即900)连不上就算超时


# 生成随机密码
randpasswd () {
    if [ "$1" = help ] || [ "$1" = '--help' ] || [ "$1" = '-h' ]
    then
        echo "Usage: \`randpasswd [length]\` to generate random passwod of this length"
        return
    fi
    if [ $# -eq 0 ]
    then
        local len=24
    else
        local len=$1
    fi
    openssl rand -base64 $len
}


# ------------------ 翻墙 ---------------------------
if [ "$(uname)" != "Darwin" ]; then
    # 非mac
    if [ -f $server_script/fanqiang/fanqiang.sh  ]; then
        . $server_script/fanqiang/fanqiang.sh
    else
        echo "$server_script/fanqiang/fanqiang.sh 找不到"  >&2
        echo "无法加载翻墙客户端、翻墙服务器的alias脚本"   >&2
    fi
fi


# dropbox loader
# 安装使用教程：https://linux.cn/article-6814-1.html
# 此软件使用前需先翻墙
# alias dbx='$server_script/dropbox_uploader.sh'
alias dbx='python2 $server_script/dropbox/dropbox.py'

# -------------------------------------------------------------------------
# sshfs
# 挂载
alias sshfs='sshfs -o allow_other,default_permissions,reconnect'

# 卸挂载
usshfs()
{
    if [ "$1" = '-h' ] || [ "$1" = '--help' ] || [ "$1" = 'help' ]; then
        echo "usshfs <mounted_path>: safe unmount when the dir is not used now"
        echo "usshfs -f <mounted_path>: forced unmount"
    elif [ "$1" = '-f' ]; then
        shift
        sudo umount -l $@
    else
        fusermount -u $@
    fi
}

# 列出目前mount的所有磁盘
alias sshfs_jch='jch sshfs'


# 实用小工具

__tz_check__()
{
    local timezone="$1"
    if [[ "$timezone" =~ ^UTC[+]{1}[0-9]+$ ]]; then
        local timezone=${timezone/+/-}
    elif [[ "$timezone" =~ ^UTC\-[0-9]+$ ]]; then
        local timezone=${timezone/-/+}
    elif [ -f "/var/db/timezone/zoneinfo/$timezone" ]; then
        :
    else
        echo "no such time zone $timezone" >&2
        return
    fi
    echo $timezone
}

tz()
{
    if [ "$1" = '-h' ] || [ "$1" = '--help' ] || [ "$1" = help ]; then
        echo 'list valid timezones'
        echo '    `tz`               list timezones/countries/continents'
        echo '    `tz <continent>`   list cities in a continent / areas in a country'
        echo
        echo 'show time zone info'
        echo '    `tz <timezone>`'
        echo
        echo '<timezone> e.g. '
        echo '    CST = UTC+8 = PRC = Asia/Shanghai'
        echo '    EST = UTC-5 = (when not in daylight time) US/Eastern = America/New_York'
        echo '    UCT = UTC-0 = (when not in daylight time) WET = Europe/London'
        echo
        echo 'convert time bwtween timezone'
        echo '    `tz <source-timezone> yyyy-mm-dd [hh=00[:mm=00[:ss=00]]] [<target-timezone>=Asia/Shanghai]`'
        return
    fi

    if [ $# -le 1 ]; then
        local tzname="$1"
        local tzpath="/var/db/timezone/zoneinfo/$tzname"
        if [ -d  "$tzpath" ]; then
            ls $tzpath
            return
        else
            local tzname="$(__tz_check__ $tzname)"
            [ "$tzname" = '' ] && return
        fi

        echo "$tzname : $(TZ="$tzname" date +'%Z UTC%z' | sed 's/\n//g')  | "\
        "now : $(TZ="$tzname" date '+%F %T 周%w' | sed 's/周0/周日/g')"
        return
    fi


    local source_TZ="$(__tz_check__ $1)"
    [ "$source_TZ" = '' ] && return

    if [[ "$3" =~ ^[0-9]{1,2}(:[0-9]{1,2}){0,2}$ ]]; then
        local source_time="$2 $3"
        shift shift
    else
        local source_time="$2"
        shift
    fi

    if [ "$1" != '' ]; then
        local target_TZ="$(__tz_check__ $4)"
        [ "$target_TZ" = '' ] && return
    else
        local target_TZ='Asia/Shanghai'
    fi

    local target_time="$(TZ="$target_TZ" date -d @$(TZ="$source_TZ" date -d  "$source_time" +%s) '+%F %T 周%w')"
    target_time="$(echo $target_time | sed 's/周0/周日/g')"
    echo $target_TZ $target_time
}


# git 的 alias
[ -f $shareENV/app/easy-git/main.sh ] && . $shareENV/app/easy-git/main.sh


# --------------------- 文件格式工具 --------------------
alias indent='python $share_script/indent_json.py' # rewrite .josn file(s) with indent

# perl 替代 sed, 支持正则正则表达式非贪婪匹配; sed不支持
alias perlsed='perl -pe'
