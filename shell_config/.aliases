#!/usr/bin/env bash


# 服务器、笔记本、WSL 共享的alias配置

[ $DotFileDebug -ne 0 ] && echo share .bash_aliases >&2


# ---------------- alias to resource ----------------
alias nvd='watch -n 10 nvidia-smi'  # 查GPU使用
alias gpu='watch -n 10 gpustat'     # 查看GPU使用，谁在用
alias gpujch='nvidia-who'            # 看用哪个进程在用显卡

# 用法
# `gpuid 0 python xxx.py` 现在暂时用GPU0运行 xxx.py
# `gpuid 0` 并不能使得接下来一直默认用GPU0运行各个程序
gpuid()
{
    # local gpuids="$1"; shift
    # eval CUDA_VISIBLE_DEVICES=$gpuids $@
    local args=""
    for i in "$@"; do
        if [[ "$i" =~ ' ' ]]; then
            local args="$args'$i' "
        else
            local args="$args$i "
        fi
    done
    eval "CUDA_VISIBLE_DEVICES=${args}"
}
# use no gpu i.e. cpu only
alias nogpu='CUDA_VISIBLE_DEVICES=-1 '

alias mem='free -h'  # 查内存使用
alias cpu='mpstat'   # 查看CPU使用率
alias yp-a='df -h' # 查看所有硬盘使用
alias yp='df -h' # 查看当前目录所在硬盘使用

alias cuda-v='nvcc -V'      # 查看cuda版本
alias cuda-vs='ls -l /usr/local/ | grep cuda'  # 查看所有cuda的安装目录

alias sys_xt='lsb_release -a'   # 查看操作系统版本
alias sys_ws='getconf LONG_BIT' # 查看系统位数
alias sys_nh='cat /proc/version' # 查看内核版本
alias sys_cpu_v='echo -n "logic cpu num:";  cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c' #  查看CPU信息（型号）
sys()
{
    echo -n "系统: "
    lsb_release -a  # 查看操作系统版本
    echo -n "位数: "
    getconf LONG_BIT   # 查看系统位数
    echo -n  "内核: "
    cat /proc/version # 查看内核版本
    echo -n "CPU: "
    echo -n "logic cpu num:"
    cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c #  查看CPU信息（型号）
}


# 总核数 = 物理CPU个数 X 每颗物理CPU的核数
# 逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数
alias pcpu_n='cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l' # 物理cpu数
cpu_nh()    # 每个物理CPU的核数
{
    echo ${$(cat /proc/cpuinfo| grep "cpu cores"| uniq)//[^0-9]/}
}
alias lcpu_n='cat /proc/cpuinfo| grep "processor"| wc -l'   # 逻辑cpu数

cxc_n() # 超线程数目
{
    echo $((10#$(lcpu_n)/10#$(pcpu_n)/10#$(cpu_nh)))
}
cpu_n()
{
    echo -n "物理CPU数："; pcpu_n
    echo -n "每CPU核数：";cpu_nh
    echo -n "逻辑CPU数：";lcpu_n
    echo -n "超线程数："; cxc_n
}


alias size='du -hd 0' # sl <dir_path>， 查看某个文件、文件夹的大小，<dir_path>缺省则为当前目录
# 数文件/文件夹个数
alias sl='python $share_script/sizelist.py' # sl <dir_path> ,查看某个目录及其下一级所有文件、文件夹的大小，<dir_path>缺省则为当前目录
# sl为size ls之意, <dir_path>缺省则为当前目录
alias count='python $share_script/countfile.py'
# 列出 指定目录下子目录 含有某字符串的 文件/文件夹 的个数
alias cl='python $share_script/countfile.py -lar'
findname() # 按名字查找
{
    if [ $# -lt 2 ]
    then
        echo "Usage: fd <path> <name>"
    else
        local argvpath=$1; shift 1
        find $argvpath -name $* 2>&1 | grep -v "Permission denied"
    fi
}

# -------------------- 网络-------------------------
alias nw='hostname -I' # 查看内网ip
# alias ww='curl ifconfig.me'
# 查看外网ip
ww()
{
    local wwip=`curl ifconfig.me` >/dev/null 2>&1
    echo $wwip
}
# 查看端口
# _dk [<port1> [<port2> ... ]]
# 其中不写端口是查看所有端口的占用情况
_dk()
{
    if [ $# -eq 0 ]; then
        sudo lsof -Pn
    else
        local ports=
        local i=
        for port in "$@"; do
            ports="$ports$port,"
        done
        eval "sudo lsof -Pn -i:$ports"
    fi
}

# strU8DiffLen () {
    # local bytlen oLang=$LANG oLcAll=$LC_ALL
    # LANG=C LC_ALL=C
    # bytlen=${#1}
    # LANG=$oLang LC_ALL=$oLcAll
    # return $(( bytlen - ${#1} ))
# }

# 查看占用某些端口的进程, 并输出端口信息、进程的信息，至少写一个端口
# _dk <port1> [<port2> ... ]
dk()
{
    if [ $# -eq 0 ]; then
        return
    fi

    local dk_return="$(_dk $@)"
    local title="$(echo $dk_return|head -n 1)"
    local content="$(echo $dk_return|sed '1d')"
    local title_short="$(echo $title|sed -E 's/^([^[:space:]]+[[:space:]]+){3}//g')"
    local content_short="$(echo $content|sed -E 's/^([^[:space:]]+[[:space:]]+){3}//g')"
    local dk_short="$title_short\n$content_short"

    local pids=($(echo $content|awk '{print $2}'))
    if [ ${#pids} -eq 0 ]; then
        return
    fi

    local jch_return=
    declare -a jch_return
    local pid=
    for pid in "${pids[@]}"; do
        jch_return=("${jch_return[@]}" "$(jchpid $pid | sed -n '2p')")
    done
    local jch_return=("$(jchpid $pid|head -n1)" "${jch_return[@]}")

    local length=0
    echo $dk_short | while read line ; do
        if (( ${#line} > $length )); then length=${#line}; fi;
    done

    local i=0
    echo $dk_short | while read line ; do
        i=$(($i + 1))
        printf "%-${length}s %s\n" "$line" "${jch_return[i]}"
    done
}

# 杀掉监听某个端口的进程
# dkd <一个端口>
kdk()
{
    kill -9 $(lsof -i:$1 | grep '(LISTEN)' | awk '{print $2}' | uniq)
}

# 测网速
ws()
{
    if [ $# -ne 0 ]; then
        echo "测试访问速度：$@"
        curl -s -w 'Testing Website Response Time for :%{url_effective}\n\nLookup Time:\t\t%{time_namelookup}\nConnect Time:\t\t%{time_connect}\nAppCon Time:\t\t%{time_appconnect}\nRedirect Time:\t\t%{time_redirect}\nPre-transfer Time:\t%{time_pretransfer}\nStart-transfer Time:\t%{time_starttransfer}\n\nTotal Time:\t\t%{time_total}\n' -o /dev/null $@
    else
        echo '网速测试：'
        curl -s https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py | python -
    fi
}

# -------------------- 进程管理 --------------------
# 搜索进程
# alias jc='ps aux | awk 'NR==1'; ps aux | grep -v grep | grep'
jch()
{
    if [ $# -eq 0 ]; then
        echo 'Usgae: jc args_for_grep'
        return
    fi
    local title="`ps aux | awk NR==1`"
    local content="`ps aux | awk NR!=1 | grep -v grep | grep $*`"
    if [ "$content" != "" ]; then
        echo $title
        ps aux | awk NR!=1 | grep -v grep | grep -v 'ps aux' | grep -v 'awk NR!=1' | grep $*
    fi
}
# 查看对应教程的pid，jchpid <pid1> [<pid2> [ <pid3>...]]
alias jchpid='ps u -p'


# 按pid杀死进程
alias kpid='kill -9'
# 按jobs的号码杀掉进程
kjob()
{
    local x=
    for x in $*
    do
        kill %$x
    done
}

# --------------------- 软件 ----------------------
# VScode
# 当有 vscode-insiders 时，有 `code-insiders` 命令
# 当有 vscode 时，有 `code` 命令
# 当有 vscode-insiders 而无 vscode 时，将 `code-insiders` 命令 alias 为 `code`
if ( ! [ -x "`which code`" ] ) && [ -x "`which code-insiders`" ]; then
  alias code='code-insiders'
fi

# _code(){
    # if ( ! [ -x "`which code`" ] ) && [ -x "`which code-insiders`" ]; then
        # command code-insiders
    # else
        # command code
    # fi
# }
_code-remote() {
    local hostname=$(echo $1 | awk -F : '{print $1}')
    local abspath=$(echo $1 | awk -F : '{print $2}')
    local has_file=$(ssh $hostname "[ -f '$abspath' ] && echo true")
    local has_dir=$(ssh $hostname "[ -d '$abspath' ] && echo true")
    if [ "$has_file" = true ]; then
        code --file-uri vscode-remote://ssh-remote+${hostname}${abspath}
    elif [ "$has_dir" = true ]; then
        code --folder-uri vscode-remote://ssh-remote+${hostname}${abspath}
    else
        echo "$hostname:$abspath not exists"
    fi
}
co(){
    if [[ "$1" =~ ':' ]]; then
        _code-remote $@
    else
        code $@
    fi
}
# alias co='code'


# 设置vim
if [ -x /usr/bin/vim.gnome ]; then
    # 更换vim-gnome, 以支持clipboard
    alias vim='/usr/bin/vim.gnome'
fi

# 设置nvim
if [ -x $serverENV/nvim/usr/bin/nvim ]; then
# 有的linux系统，没有fuse，故无法执行此镜像（但mac可以执行） `# alias nvim=$serverENV/local/bin/nvim.appimage`
    export PATH=$serverENV/nvim/usr/bin/:$PATH
    # alias nvim=$serverENV/nvim/usr/bin/nvim
fi

# mac上用`brew install newvim` （neovim内核）并 `pip install neovim`（python支持）
# 安装完成后自带nvim命令
alias nvi=nvim
alias nv=nvim
alias v=nvim
alias vi=vim

# 设置默认编辑器
# if ( [ -x "`which code-insiders`" ] && [ "`which code-insiders`" != '/usr/bin/code' ] ) || \
   # ( [ -x "`which code`" ] && [ "`which code`" != '/usr/bin/code' ] ) ; then
    # alias default_editor='code'
if [ -x $serverENV/nvim/usr/bin/nvim ]; then
    alias default_editor=nvim
else
    alias default_editor=vim
fi


# sub(){
#     if [ -d /Applications/Sublime\ Text.app ]; then
#         # 本地是Mac，且有sublime
#         open -a "/Applications/Sublime Text.app" $*
#     else
#         # 本地非mac，或无sublime
#         echo "\"open sublime on mac client\""
#         sleep 0.1
#         dirs=""
#         for arg in $@; do
#             if [ -f $arg ]; then
#                 # echo "用笔记本上的sublime开文件 $arg"
#                 # 但文件走rsub
#                 rsub $arg
#                 n_file=1
#             elif [ -d $arg ]; then
#                 # echo "用笔记本上的sublime开文件夹: $arg"
#                 dirs="$dirs $(cd $arg; pwd)"
#             else
#                 echo no directory or file $arg
#             fi
#         done
#         if [ "$dirs" != "" ]; then
#             # 文件夹走sftp
#             # 以备iterm2抓取用户、服务器、文件夹路径，从而用远程的sublime sftp开
#             echo "user: $USER; hostname: `hostname`; path: '$dirs'"
#         fi
#     fi
# }

abspath(){
    echo $(cd $(dirname "$1") && pwd -P)/$(basename "$1")
}
# sub(){
    # if [ -d /Applications/Sublime\ Text.app ]; then
        # # 本地是Mac，且有sublime
        # open -a "/Applications/Sublime Text.app" $*
    # else
        # # 所有文件走sshfs，可以开文件夹和文件
        # dirs=""
        # for arg in $@; do
            # if [ -e $arg ]; then
                # path_arg=$(abspath $arg)
                # dirs="$dirs '$path_arg'"
            # else
                # echo not exist: $arg
            # fi
        # done
        # if [ "$dirs" != "" ]; then
            # echo  "local open app: sub; user: $USER; hostname: `hostname`; path: $dirs"
        # fi
    # fi
# }

# if [ "$(uname -o)" != "Darwin" ]; then
    # # 不是mac
    # open(){
        # dirs=""
        # for arg in $@; do
            # if [ -e $arg ]; then
                # path_arg=$(abspath $arg)
                # dirs="$dirs '$path_arg'"
            # else
                # echo not exist: $arg
            # fi
        # done
        # if [ "$dirs" != "" ]; then
            # echo  "local open app: open; user: $USER; hostname: `hostname`; path: $dirs"
        # fi
    # }
# fi

_open() {
    local app="$1"
    shift
    local dirs=
    local arg
    for arg in $@; do
        if [ -e $arg ]; then
            local path_arg=$(abspath $arg)
            dirs="$dirs; $path_arg"
        else
            echo not exist: $arg
        fi
    done
    # 去掉dirs字符串开头的'; '
    if [ "${dirs:0:2}" = "; " ]; then
        dirs=${dirs:2}
    fi
    if [ "$dirs" != '' ]; then
        echo 'remote open: '"$app"'; '"$USER"'; '"`hostname`"'; '"$dirs"
    fi
}

if [ "$(uname)" != "Darwin" ]; then
    # 不是mac
    if ! [ -x "`which code`" ]; then
        # 没有code命令（即在服务器上，且目前不是用vscode远程登录）
        alias code='_open code'
    fi
    alias open='_open open'
    alias sub='_open sub'
else
    if [ -d /Applications/Sublime\ Text.app ]; then
        # 本地是Mac，且有sublime
        alias sub='open -a "/Applications/Sublime Text.app"'
    fi
fi



server_port=8304 # 【远程nc端口】

rsubl(){
    local dirs=""
    local arg
    for arg in $@; do
        if [ -e $arg ]; then
            local path_arg=$(abspath $arg)
            dirs="$dirs; $path_arg"
        else
            echo not exist: $arg
        fi
    done
    if [ "${dirs:0:2}" = "; " ]; then
        dirs=${dirs:2}
    fi
    if [ "$dirs" != "" ]; then
        (echo "sub; $USER; `hostname`; $dirs" | nc localhost $server_port  & )   > /dev/null
    fi
}

ropen(){
    local dirs=""
    local arg
    for arg in $@; do
        if [ -e $arg ]; then
            local path_arg=$(abspath $arg)
            dirs="$dirs; $path_arg"
        else
            echo not exist: $arg
        fi
    done
    if [ "${dirs:0:2}" = "; " ]; then
        dirs=${dirs:2}
    fi
    if [ "$dirs" != "" ]; then
        (echo "open; $USER; `hostname`; $dirs" | nc localhost $server_port & )   > /dev/null
    fi
}

# --------------- alias dotfile ----------------------
se=~/.shell_config/.env;      sse=$share_shell_config/.env
si=~/.shell_config/.login;
so=~/.shell_config/.logout;
sa=~/.shell_config/.aliases;  ssa=$share_shell_config/.aliases

be=~/.bash_env
bp=~/.bash_profile
br=~/.bashrc;                      sbr=$share_shell_config/.bashrc
bo=~/.bash_logout

ze=~/.zshenv
zp=~/.zprofile
zr=~/.zshrc;                       szr=$share_shell_config/.zshrc
zo=~/.zlogout

# others
alias vtmux='default_editor ~/.tmux.conf'
alias stmux='tmux source-file ~/.tmux.conf'
alias vv='vim ~/.vimrc'           # vim 免source，重新开vim即生效
alias vvp='vim ~/.vimrc.bundles'      # vim 的插件
alias ivp="vim  +'PlugInstall --sync' +qa"  # 按照.vimrc.bundles下载安装之前没有的vim的插件
alias uvp="vim  +'PlugInstall --sync' +'PlugUpdate' +qa"  # 按照.vimrc.bundles下载安装之前没有的vim的插件，并升级已有插件
alias make_ycm='$HOME/.vim/plugged/YouCompleteMe/install.sh' # 编译YouCompleteMe
fix_ycm() {
    # 参考：https://www.lizenghai.com/archives/22681.html
    ycm_path="$HOME/.vim/plugged/YouCompleteMe"
    mkdir -p $ycm_path/third_party/go/src/golang.org/x
    cd $ycm_path/third_party/go/src/golang.org/x
    git clone https://github.com/golang/tools.git

    cd $ycm_path/third_party/ycmd/third_party/go/src/golang.org/x
    git clone https://github.com/golang/tools.git

    cd $ycm_path
    git submodule update --init --recursive

    $ycm_path/install.sh
}


alias vgit='default_editor ~/.gitconfig'

fix_golang()
{
    # 法一：https://www.lizenghai.com/archives/22681.html
    local ycm_path="$HOME/.vim/plugged/YouCompleteMe"
    mkdir -p $ycm_path/third_party/go/src/golang.org/x
    cd $ycm_path/third_party/go/src/golang.org/x
    git clone https://github.com/golang/tools.git

    cd $ycm_path/third_party/ycmd/third_party/go/src/golang.org/x
    git clone https://github.com/golang/tools.git

    cd $ycm_path
    git submodule update --init --recursive

    $ycm_path/install.sh
}

fix_zsh_history()
{
    mv ~/.zsh_history ~/.zsh_history_bad
    strings ~/.zsh_history_bad > ~/.zsh_history
    fc -R ~/.zsh_history
    rm ~/.zsh_history_bad
}

# ---------------- 环境显示 -----------------------
# 显示路径，换行分隔，例如 `showpa PATH`， `showpa <任何一环境变量>`
showpa()
{
    eval "echo \$$1 | sed 's/:/\'$'\n/g'"
}
# 添加路径，例如 `addpa PATH <新路径>`
addpa()
{
    eval "export $1=$2:\$$1"
}
# 删除路径，例如 `addpa PATH <待删除路径>` ，若待删除路径不在$PATH中，则不对$PATH做更改
rmpa()
{
    newpath=$(eval "echo \$$1 | sed 's:$2\:::g' | sed 's:\:$2::g'")
    # 路径有'/'，用'/'分隔会冲突，改用':'分隔
    eval "export $1=$newpath"
}

# ssh
alias vssh='default_editor ~/.ssh/config';
alias vhost='default_editor /etc/hosts' # 系统文件，个人账号用sub看不了
alias sendkey='ssh-copy-id'     # 发送公钥


# ---------------- alias cp、scp ----------------

# 拷贝、传输一个文件或文件夹（及其下各级所有文件），包括隐藏文件
alias cp="cp -r"
alias scp="scp -r"

# 自动端点续传，传送失败后隔180秒自动重新连接
# autots（alias）会被下面的autots函数覆盖，用来使得下面的autots函数能够和rsync一样自动补全远程目录
alias autots_='rsync'
autots() {
    echo yes
    local retry_time=180 # second
    while [ 1 ]
    do
        rsync -aHhvzP $*
        # command 调用系统的 rsync 命令，避免递归调用rsync
        if [ "$?" = "0" ] ; then
            echo "rsync completed normally"
            break
        else
            echo "Rsync failure. Backing off and retrying in $retry_time seconds..."
            sleep $retry_time
        fi
    done
}
# rsync 封装多种参数，但不支持断点续传; ts能够和rsync一样自动补全远程目录
alias ts='rsync -aHhvz --progress'

# `cp 目录/.`   拷贝一个目录下所有文件，目录自身不拷，拷隐藏文件
# cp_under 一个或多个源目录 目标目录
cp_under()
{
    local sourcepaths=${*:1:$#-1}
    local targetpath=${*:$#:1}
    local x=
    for x in $sourcepaths
    do
        cp $x/. $targetpath
    done

}

# `cp 目录/*`   拷贝一个目录下所有文件，目录自身不拷贝，不拷隐藏文件
# cp_under_vis 一个或多个源目录 目标目录
cp_under_vis()
{
    local sourcepaths=${*:1:$#-1}
    local targetpath=${*:$#:1}
    local x
    for x in $sourcepaths
    do
        cp $x/* $targetpath
    done
}

# -------------------- alias to ls ---------------------
alias tree='tree -N'  # -N 原编码输出，以避免在mac上中文路径出现乱码

#  -F  文件夹结尾加/
#  -C  多列
#  -A  显示隐藏文件
#  -l  use a long listing format, 即显示所有文件信息，一个文件一行
#  -G  in a long listing, don't print group names
#  -h  文件大用kMG单位
# 显(xxx)隐(.xxx) 文件(xxx)文件夹(xxx/) 用户名 大小 创建日期 大小用GMk格式
alias ll='ls -AlFh'
# 显(xxx)隐(.xxx) 文件与文件夹不区分(xxx)
alias la='ls -CAF'
# 显 文件(xxx)文件夹(xxx/)
alias l='ls -CF'


# safe remove
# sr file(s) or dir(s)
# mv to $my/trash/
# if the file/dir name conflicts with those in trash/, add time prefix on it
# support file/dir name conatins spaces and non-ascii chars
if [ "$(uname)" = "Darwin" ]; then
# mac
    trash=~/.Trash
else
# linux
    trash=$my/trash
fi

srm()
{
    if ! [ -d $trash ]; then
        echo $trash not existes, now made one
        mkdir $trash -p
    fi

    local i=
    for i in $*; do
        local base="$(basename $i)"
        if [ -e "$trash/$base" ] || [ -L "$trash/$base" ]; then
            local prefix=$(date "+%Y-%m-%d-%H:%M:%S")
            mv "$i" "$trash/$prefix.$base"
        else
            mv "$i" "$trash"
        fi
    done
}
# 安全清空目录，包括隐藏文件（夹）
srm_under()
{
    local x=
    for x in $*
    do
        srm $x/{*,.[!.]*}
    done
}
# 直接清空目录，包括隐藏文件（夹）
rm_under()
{
    local x=
    for x in $*
    do
        if [ -n "$ZSH_VERSION" ]; then  # zsh 下
            rm $x/{*,.*} -rf
        else
        # elif [ -n "$BASH_VERSION" ]; then # bash 下
            rm $x/{*,.[!.]*} -rf
        fi
    done
}

alias md='mkdir'
alias g='grep'
alias lk='ln -s'
# lk <原身路径：可是文件、文件夹> [ <链接路径与名称> 默认是 . ]
# 创建软连接
alias ..='cd ../'
c()
{
    if [ $# = 0 ]
    then
        cd $my
    else
        cd $*
    fi
}
# 授权bash文件可执行
alias kzx='chmod +x'  # kzx 文件名： 设为可执行
alias bkzx='chmod -x' # bkzx 文件名：设为不可执行
# 改所有者：own <用户名>(:<组名>) 文件名
alias own='chown -R' # -R表示递归，即文件夹下诸物皆然

# -------------------------------------------------------------------------
# 压缩软件
# 7z压缩
ys()
{
    if [ "$1" = '-h' ] || [ "$1" = '--help' ] || [ "$1" = 'help' ]; then
        echo 'Usage:'
        echo '    ys 一个文件夹或文件  :    得到 <同名>.7z'
        echo '    ys 一到若干个文件或文件夹 xxx.7z(".7z"可省略)'
    else
        local file7z=${@:$#}
        local filehead=`echo $file7z | sed -E 's/.7z$//g'`
        local to_be_compressed="${@:1:`expr $# - 1`}"
        ! [ $to_be_compressed ] && to_be_compressed=$filehead
        eval "7z a ${filehead}.7z ${to_be_compressed}"
    fi
}

# 7z解压
jy()
{
    if [ "$1" = '-h' ] || [ "$1" = '--help' ] || [ "$1" = 'help' ]; then
        echo 'Usage:'
        echo 'jy7z xxx.7z 目标目录(缺省为.)  :  解压到`目标目录/xxx_extract`'
    else
        local file7z=$1; shift 1
        if [ $# -ne 0 ]; then
            local target_jieya_path=$1
        else
            local target_jieya_path=.
        fi

        # local OLD_IFS=$IFS
        # IFS='.'
        # local tmp=($(echo "$file7z"))
        # IFS=$OLD_IFS
        # local filehead="${tmp[1]}"
        local filename="${file7z}_extract"

        # local filehead=`echo $file7z | sed -E 's/.7z$//g'`
        # `7z x`一次只能解压一个文件
        eval "7z x ${file7z} -o${target_jieya_path}/${filename}"
    fi
}

# 通用解压
# alias jy='dtrx'
# 用法：
#     cd到解压路径
#     jy 压缩文件的路径（可以多个）
#     则自动将其解压到同名文件夹

# 更换默认shell
setsh()
{
    which $1  && chsh -s `which $1`
}
# -------------- 删除mac特有隐藏文件 --------------
# 删除 .DS_store 和 ._* 文件
# alias macdot_clean='find . \( -type f \( -name "._*" \) -o \( -name ".DS_Store" \) \) -delete'

# 删除 .DS_store 和 ._* 文件
# macdotrm ：删除当前目录下的这些文件
# macdotrm -r ：删除当前目录及其各级子目录下的这些文件
macdotrm()
{
    if [ "$1" = "-r" ]; then
        find . \( -type f \( -name "._*" \) -o \( -name ".DS_Store" \) \) -delete
    else
        rm -f ._*
        rm -f .DS_Store
    fi
    rm -rf __MACOSX
}
# ---------------- alias to conda --------------
# 清华tuna源，官网https://mirrors.tuna.tsinghua.edu.cn/news/#oh-my-tuna
# # 国内默认使用tuna，装包会快很多
tuna()
{
    if [ "$1" = '--global' ]; then
        python $share_app_config/oh-my-tuna.py --global
    elif [ "$1" = 'install' ] || [ "$1" = 'update' ] ; then
        wget https://tuna.moe/oh-my-tuna/oh-my-tuna.py -O $share_app_config/oh-my-tuna.py --no-check-certificate
    elif [ "$1" = '-h' ] ||  [ "$1" = '--help' ] ||  [ "$1" = 'help' ] ; then
        echo "-------------------------------------------------------------------------"
        echo '                         help for the alias `tuna`'
        echo "tuna [ install | update]  : download the newest oh-my-tuna from \n      https://tuna.moe/oh-my-tuna/oh-my-tuna.py"
        echo "tuna [ help | -h | --help ] : for help"
        echo "tuna : apply tuna for the one user yourself"
        echo "sudo tuna --global : apply tuna for the all users"
        echo "tuna [arguments] : [arguments] follows oh-my-tuna.py"
        echo "-------------------------------------------------------------------------"
        python $share_app_config/oh-my-tuna.py -h
    else
        python $share_app_config/oh-my-tuna.py $*
    fi
}

alias act='source activate'
alias dea='conda deactivate'
alias els='conda info -e' # 列出conda的环境
enew() # enew 环境名字 python的版本  其他参数
{
    conda create -n $1 python=$2 ${@:3:$#}
}
ecp() # ecp 源环境名字 新环境名字
{
    conda create -n $2 --clone $1
}
erm() # erm 环境的名字
{
    conda remove -n $1 --all
}

# ---------------- alias to python ------------------
alias py='python'
alias py3='python3'
alias py2='python2'
alias ipy='ipython'
alias nb='jupyter notebook' # open local jupyter notebook, it will automatically call safari to open the webpage

# tb [装event文件的目录(默认为.)], 不能是event，可以是其下一级或多级含有event的目录
# tb 实验名: 装event文件的目录 实验名: 装event文件的目录 实验名: 装event文件的目录 ...
tb()
{
    local dir_paths
    declare -a dir_paths
    while [ $# -ne 0 ]; do
        if [[ "$1" =~ "^-"  ]]; then
            break
        else
            if [[ "$1" =~ ':$' ]]; then
                local dir_path="$1$2"
                shift
            else
                local dir_path="$1"
            fi
            dir_paths=("${dir_paths[@]}" "$dir_path")
            shift
        fi
    done

    if [ ${#dir_paths} -eq 0 ]; then
        local dir_arg='--logdir=.'
    # elif [ ${#dir_paths} -eq 1 ]; then
        # local dir_arg="--logdir=${dir_paths[1]}"
    else
        dir_arg='--logdir_spec='
        local i
        for i in "${dir_paths[@]}"; do
            dir_arg="${dir_arg}${i},"
        done
        dir_arg="${dir_arg:0:-1}"
    fi

    tensorboard $dir_arg $@
}
# -----------------  alias to tmux ------------------
# list all session of tmux session
alias tl='tmux ls'
# kill a tmux session
alias tk='tmux kill-session -t'
# kill all tmux sessions i.e. kill the tmux server
tka()
{
    local answer=$(bash -c "read  -n 1 -p 'Do you want to kill the tmux server? [Y|N]' c; echo \$c")
    echo
    if [ "$answer" = "y" ] || [  "$answer" = "Y"  ]; then
        tmux kill-server
        echo 'killed'
    else
        echo "didn't kill"
    fi
}

#              命令   (i)tm                      (i)tm 已有session名    (i)tm 新session名
# 无tmux session 时   创建名为的default的session    --                   创建session
# 有tmux session 时   attach最近的session         attach该session       创建session
# itm:与iterm2关联的tmux
# tm：不关联iterm2的tmux
# compinit
if [ "$(which compdef 2>/dev/null)" != '' ]; then
    tmux_itm() { : }
    compdef _tmux tmux_itm
    alias itm='tmux_itm -CC attach -t'
fi
# rm -f ~/.zcompdump; compinit


# echo _tmux
# which _tmux
# compinit
# compdef '_dispatch tmux tmux' tmux_itm

itm() {
    for i in {1..3}; do shift; done
    echo "itm $@"
    if [ $# = 0 ]; then
        tmux -CC attach || tmux -CC new -s default
    else
        local session="$1"
        tmux -CC attach -t "${session}" || tmux -CC new -s "${session}"
    fi
}


if [ "$(which compdef 2>/dev/null)" != '' ]; then
    tmux_tm() { : }
    compdef _tmux tmux_tm
    alias tm='tmux_tm attach -t'
fi

tm() {
    for i in {1..3}; do shift; done
    echo "tm $@"
    if [ $# = 0 ]; then
        tmux attach || tmux new -s default
    else
        local session=$1
        tmux attach -t ${session} || tmux new -s ${session}
    fi
}
# alias tm='zsh -c '\''_tm $@'\'' _ || echo -n || tmux attach -t'

# ------------------ git ----------------------------
# 初创
alias gi='git init'       # 创建.git:    cd 项目文件夹; gi
# 暂存
alias gs='git status'     # 查看当前状态:  gs
alias ga='git add'        # 暂存增改文件:  ga 文件
alias gaa='git add -A .'  # 暂存所有增删改文件：gaa

# 查看跟踪的文件和文件夹，并自动着色
# list files or dirs traced or ignored by git
# gitls [<path> [<path> ...]] [--ignore] [<other-args-of-ls>]
#   --ignore         : ls files ignored by git, and dirs contain such files
#   without --ignore : ls files traced by git, and dirs contain such files
#   without <path>   : ls files or dirs under current path
# auto colored
gls()
{
    local git_args=''
    local ls_args=''
    local dir_paths
    declare -a dir_paths
    while test $# -gt 0
    do
        case "$1" in
            --ignore)  git_args='-o -i --exclude-standard' ;;
            -*)        ls_args="$ls_args $1"  ;;
            --*)       ls_args="$ls_args $1" ;;
            *)         dir_paths=("${dir_paths[@]}" "$1");;
        esac
        shift
    done

    local gls_command="git ls-files $git_args | awk -F / '{print \$1}' | uniq | sed 's/\ /\\\ /g' | xargs ls -dh --color=auto $ls_args"

    if [ ${#dir_paths} -eq 0 ]; then
        eval "$gls_command"
    else
        local here_path="$(pwd | sed 's/\ /\\\ /g')"
        for dir_path in "${dir_paths[@]}"; do
            echo
            echo -E "$dir_path:" | sed 's/\ /\\\ /g'
            cd $dir_path
            eval "$gls_command"
            cd $here_path
        done
    fi
}
# 几个文件一行，不显示文件详细信息
alias gl='gls'
alias gli='gls --ignore'
# 一个文件一行，显示详细信息
alias gll='gls -l'
alias glli='gls -l --ignore'

# alias gll='git ls-files | awk -F / '\''{print $1}'\'' | uniq | sed '\''s/\ /\\\ /g'\'' | xargs ls -dl --color=auto'

alias grm='git rm -rf'    # （删除并）暂存删除： grm 文件             ；用于替代rm
alias gmv='git mv'        # （移动并）暂存移动： gmv 文件 文件夹       ；用于替代mv
alias gdf='git diff'      # 改过未add、add了 文件 时，看文件与上次提交的区别：gdf 文件
gum(){
    if [ $# = 0 ]; then
        echo 'Usage: 撤销未暂存的修改. 无法撤销修改先前未跟踪的文件'
        echo ' gum  <filename> [ <filename> [ <filename> ...]]'
        echo ' gum  -all : 所有为暂存的修改'
    elif [ "$1" = "-all" ]; then
        git checkout .
    else
        git checkout -- $*
    fi
}
gua(){
    if [ $# = 0 ]; then
        echo 'Usage: 撤销暂存，对 `git add` `git rm`有效 '
        echo ' gua  <filename> [ <filename> [ <filename> ...]]'
        echo ' gua  -all : 撤销所有暂存'
    elif [ "$1" = "-all" ]; then
        git reset HEAD
    else
        git reset HEAD $*
    fi
}
# 提交
alias gcm='git commit -m'  # 提交：gcm "xxx" [options]
alias gcma='git commit --amend' # 先add，再覆盖上一次提交：gcma，然后弹出文本编辑器，编辑上次提交的说明
gucm() # 直接回到历史版本
{
    if [ $# = 0 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
        echo 'Usage: 恢复到历史版本， alias =`git reset --hard`'
        echo ' gucm 0: 恢复到最近一次git commit后'
        echo ' gucm ^: 恢复到父版本'
        echo ' gucm ^n: 恢复到n父版本'
        echo ' gucm -n: 恢复到HEAD@{n}'
        echo '     `ghs`: 查看所有版本操作的哈希码和HEAD@{n}，如`git commit/reset/revert`'
        echo '            其中 HEAD@{n}: 依时间顺序，倒数第n个版本（当前版本为第0）'
        echo '            例如 `gucm ^` 再 `gucm -1`, 等价于`gucm 0`'
        echo ' `gucm 哈希码/HEAD@{n}/HEAD/HEAD^/HEAD~n`'
        echo '     `glg`: 查看历史版本的的哈希码'
    else
        local answer=$(bash -c "read  -n 1 -p '请先git commit再reset，不然抛弃暂存和修改 无法恢复。是否继续reset [Y|N]' c; echo \$c")
        echo
        if [ "$answer" = "y" ] || [  "$answer" = "Y"  ]; then
            local target_version=$1
            if [ "$1" = "0" ]; then
                echo git reset --hard HEAD
                git reset --hard HEAD
            elif [ "$1" = "^" ]; then
                echo git reset --hard HEAD^
                git reset --hard HEAD^
            elif [ "${target_version:0:1}" = "^" ]; then
                local n=${target_version:1:${#target_version}}
                echo git reset --hard HEAD~$n
                git reset --hard HEAD~$n
            elif [ "${target_version:0:1}" = "-" ]; then
                local n=${target_version:1:${#target_version}}
                echo git reset --hard HEAD@{$n}
                git reset --hard HEAD@{$n}
            else
                echo git reset --hard $1
                git reset --hard $1
            fi
        fi
    fi
}
grcm() # 反向提交到某个版本
{
    if [ $# = 0 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
        echo 'Usage: 反向提交返回历史版本， alias = `git revert`'
        echo ' grcm ^: 到上一版本'
        echo ' grcm ^n: 到前n版本'
        echo ' grcm <版本哈希/HEAD^/HEAD~n>: 反向提交若干次，回到上此<版本>，它必需是HEAD的祖宗版本'
        echo ' 若有暂存、修改，则无法执行，需先git commit 或 抛弃暂存、修改（`gucm 0`）'
    else
        local target_version=$1
        if [ "${target_version}" = "^" ]; then
            git revert HEAD^..HEAD      # 反向提交一次，回到上一版本
        elif [ "${target_version:0:1}" = "^" ]; then
            local n=${target_version:1:${#target_version}}
            git revert HEAD~${n}..HEAD      # 反向提交一次，回到上一版本
        else
            git revert $1..HEAD  # 反向提交若干次，回到$1版本，$1为版本哈希/HEAD^/HEAD~n
        fi
    fi
}

gig()   # 修改.gitignore 后，commit一版
{
    git rm -r --cached .  #清除缓存
    git add . #重新trace file
    git commit -m "update .gitignore" #提交和注释
}

# 分支
gb()                      # 新建分支并检出到此分支： gb 分支名
{
    git branch $1 && git checkout $1
}
alias gbrm='git branch -d' # 删除分支：gbrm 分支名
alias gbls='git branch -avv' # 列出所有本地枝，及其关联的远枝： gbls
alias gch='git checkout'    # 切换分支：gch 分支名/历史提交编号/HEAD^/HEAD/HEAD~n/HEAD@{n}, 要先git commit一次才能gch
alias gmg='git merge'       # 将其与当前枝合并：gmg 待合并分支
# 历史
alias glg="git log --graph --oneline --all --pretty=format:'%C(yellow)%h%Creset%C(auto)%d%Creset %Cgreen%cr %C(bold blue)%an%Creset %s' --abbrev-commit --date=short"  #列出提交历史图谱，含远仓、本仓
alias glgs='glg --simplify-by-decoration'               #列出简化历史图谱
alias ghs='git reflog'   # 按时间顺序列出 版本重置（git reset）、提交（git commit）
# 远仓
alias gra='git remote add'        # 关联远仓：gra 远仓名（即远程repo在本地的名字） 远程repo的网址

alias grrm='git remote rm'      # 取关远仓：    grrm 远仓名
alias grrn='git remote rename'  # 重命名远仓：  grrn 远仓名
alias grls='git remote show'    # 列出远仓：    grls
                             # 显示远仓信息： grls 远仓名
# 远枝
# alias gbu='git branch -u'                # 将当前枝关联远枝：           gup 远仓名 远枝名
git_current_branch()
{
    git branch | grep \* | cut -d ' ' -f2
}
gbu()
{
    if [ $# = 0 ]; then
        local remote=origin
        local remote_branch=`git_current_branch`
    elif [ $# = 1 ]; then
        local remote=$1
        local remote_branch=`git_current_branch`
    elif [ $# = 2 ]; then
        local remote=$1
        local remote_branch=$2
    else
        echo 'Aruments: [remote [remote_branch]]'
        echo '    default remote=origin'
        echo '    default remote_branch=<current_local_branch_name>'
        echo 'if remote_branch does not exist on remote repo, it will be created'
        return
    fi
    echo "-----------------------------------------------------------------------"
    echo "remote: $remote; remote_branch: $remote_branch"
    echo "git fetch $remote $remote_branch"
    git fetch $remote $remote_branch
    echo "fetched"
    echo "-----------------------------------------------------------------------"
    echo "git branch --set-upstream-to=$remote/$remote_branch"
    git branch --set-upstream-to=$remote/$remote_branch
    echo "upstream branch has set"
    echo "-----------------------------------------------------------------------"
}
alias gbuu='git branch --unset-upstream' # 将当前枝取关远枝：   guu [本地分支名，默认为当前分支]


# 推拉



gpsu()
{
    if [ $# = 0 ]; then
        local remote=origin
        local remote_branch=`git_current_branch`
    elif [ $# = 1 ]; then
        local remote=$1
        local remote_branch=`git_current_branch`
    elif [ $# = 2 ]; then
        local remote=$1
        local remote_branch=$2
    else
        echo 'Usgae: gpsu [remote [remote_branch]]'
        echo '    default remote=origin'
        echo '    default remote_branch=<current_local_branch_name>'
        echo 'if remote_branch does not exist on remote repo, it will be created'
        return
    fi
    echo $remote $remote_branch
    git push -u $remote $remote_branch
}

#  初次推送用，关联远枝并推送，若远仓无此远枝，则创建之
# gpsu [远仓名 [远枝名]]，  默认远仓名=origin， 默认远枝名=本地现枝名
# gpsu()
# {
    # gbu $*
    # git push
# }
alias gps='git push'     # 推送当前枝：            gps [ 远仓名 [远枝名]]
alias gfc='git fetch'           # 拉去到当前枝：          gfc [ 远仓名 [远枝名]]
# gplu [远仓名 [远枝名]],   初次拉用
gplu()
{
    gbu $*
    git pull
}
alias gpl='git pull'            # 拉去到当前枝并与之合并：  gpl [ 远仓名 [远枝名]]
                                # gps，gfc，gpl皆可省参数：
                                # 若该远仓的远枝已关联，则[远枝名]不写
                                # 若还只关联一个远仓，则[ 远仓名 [远枝名]]不写
alias gcl='git clone'           # 克隆远枝：gcl 远仓网址
                                # 请用http格式，若用ssh格式则需要验证密钥

gmed()  # 修改提交信息：  gmed <版本id>
#    只接收一个版本id
#    只接收版本hash，不接受HEAD, HEAD^, HEAD@{n}
#    不能是第一个版本
{
    local commitid=$1
    GIT_SEQUENCE_EDITOR="sed -i -re 's/^pick ${commitid}/r ${commitid}/'" git rebase -i ${commitid}^
}

# -------------------------------------------------------------
# -- 自动添加.gitkeep到文件夹下，以使得git add能加入空文件夹

# _level a/b/c/d （只接受一个参数）
# 输出
# a
# a/b
# a/b/c
_level()
{
    local SAVE_IFS=$IFS
    IFS=$(echo -en "\n\b")
    local apath=$1
    while [ 1 ]; do
        echo $apath
        local newpath=$(dirname $apath)
        if [ "$newpath" == "$apath" ]; then
            break
        else
            apath=$newpath
        fi
    done
    IFS=$SAVE_IFS
}

# _not_exist_dir path1 [path2 [path3 ....]]
# 输出 一行一个路径，只输出存在的路径
_not_exist_dir()
{
    local SAVE_IFS=$IFS
    IFS=$(echo -en "\n\b")
    local i=
    for i in $*; do
        local tmp=($(_level $i))
        for j in ${tmp[@]}; do
            ! [ -d $j ] &&  echo $j
        done
    done
    IFS=$SAVE_IFS
}

# _getpath path ... -x=xxx path -xxx path  --xx=xx path --xxx
# -x --xxx -x=xxx --xx=xxx 都是参数
# 输出 path path .. path
_getpath()
{
    local SAVE_IFS=$IFS
    IFS=$(echo -en "\n\b")
    local i=
    for i in $* ; do
        ! [ "${i:0:1}" = "-" ] && echo $i
    done

    IFS=$SAVE_IFS
}

# gmd path [path [path ..]]] [-参数]
# 每创建一个新文件夹，会在其下自动加一个.gitkeep文件
# 参数需要写成  -x -xyz --xxx -x=abc --xx=abc
# 不可写成 -x abc 或 --xx abc, 即必须有等号，等号前后不能有空格
# 参数含义同mkdir
gmd()
{
    local SAVE_IFS=$IFS
    IFS='
'
    local tmp=($(_not_exist_dir $(_getpath $*)))

    mkdir $*

    local i=
    for i in ${tmp[@]}; do
        echo 2: $i
        if [ -d $i ]; then
            touch $i/.gitkeep
        else
            echo $i not exist
        fi
    done

    IFS=$SAVE_IFS
}

# gitkeep [path [path ..]] # 缺省为当前目录
# 将当前目录下的所有空文件夹下创建.gitkeep文件
gitkeep()
{
    if [ $# -eq 0 ]; then
        find . -type d -empty -not -path "./.git/*" -exec touch {}/.gitkeep \;
    else
        find $* -type d -empty -not -path "./.git/*" -exec touch {}/.gitkeep \;
    fi
}

# -------------------------------------------------------------------------
# github api
gh()
{
    if [ "$1" = 'test' ]; then
        ssh -T git@github.com # 测试github的ssh连接
    elif [ "$1" = 'ls' ]; then
    # list all remote repo
        echo $(curl -H "Authorization: token $(<~/.ssh/github.token)" https://api.github.com/user/repos 2>/dev/null | \
        grep -E '^    "name":|^    "private": ' ) | \
        sed 's/"name": "/\
/g' | \
        sed 's/"\, "private": false\,//g' | \
        sed 's/"\, "private": true,/ \[private\]/g'
    elif [ "$1" = 'new' ]; then
    # create new remote repo
        local repo_name="$2"
        if [ $# -eq 3 ]  && [ "$3" = 'public' ]; then
            local ifPrivate=false
        else
            local ifPrivate=true
        fi
        curl -H "Authorization: token $(<~/.ssh/github.token)" https://api.github.com/user/repos --data "{ \"name\": \"$repo_name\",  \"private\": $ifPrivate }"
    elif [ "$1" = 'add' ]; then
        shift
        grgh $@
    else
        echo '`gh test` : test github ssh connection'
        echo '`gh ls` : list all your repo, it can inform you whether they are private'
        echo '`gh new {repo_name}` : create a private repo'
        echo '`gh new {repo_name} public` : create a public repo'
        echo '`gh add [{remote} [{github_username}]] {remote_repo_name}` : add a github repo as '
        echo '    default {remote}: origin'
        echo '    default {github_username}: local git username, see in `git config user.name`'
    fi
}
# git remote git hub
grgh()  # 关联github上的远程repo
# 先在github上建立一个repo
# 然后用此，用法见下
{
    if [ $# = 1 ]; then
        local user=`git config user.name`
        local name=origin
        local repo=$1
    elif [ $# = 2 ]; then
        local user=`git config user.name`
        local name=$1
        local repo=$2
    elif [ $# = 3 ]; then
        local name=$1
        local user=$2
        local repo=$3
    else
        echo 'Usage: gh [remote [github_username]] remote_repo_name'
        echo '    default remote: origin'
        echo '    default github_username: local git username, see in `git config user.name`'
        return
    fi
    echo $user $name $repo
    git remote add $name git@github.com:$user/$repo.git
}


# -------------------------------------------------------------------------

# vnc server 桌面转发
vncs(){
    if [ $# -eq 0 ] || [ "$1" = "start" ] ; then
        vncserver :1 -geometry 1366x768
    elif [ "$1" = "stop" ]; then
        vncserver -kill :1
    elif [ "$1" = "restart" ]; then
        vncserver -kill :1
        vncserver :1 -geometry 1366x768
    elif [ "$1" = "passwd" ]; then
        vncpasswd
    elif [ "$1" = "config" ]; then
        default_editor ~/.vnc/xstartup
    elif [ "$1" = "help" ]; then
        echo 'Usage: vnc [ start(default)) | stop | restart | passwd | config | help ]'
    else
        echo 'Usage: vnc [ start(default)) | stop | restart | passwd | config | help ]'
    fi
}

# vnc viewer
# 用法：vnc 服务器别名
alias vncv='ssh -L 5901:127.0.0.1:5901 -C -N'
# -C 压缩所有数据；  -N 只转发端口 不能在远程终端下执行命令

# -------------------------------------------------------------------------
alias wgetc='wget -C -t 0'
# '-C'断点续传，' -t 0' 无限次断开次续传，'-T 900' 表示900秒(缺省即900)连不上就算超时


# 生成随机密码
randpasswd () {
    if [ "$1" = help ] || [ "$1" = '--help' ] || [ "$1" = '-h' ]
    then
        echo "Usage: \`randpasswd [length]\` to generate random passwod of this length"
        return
    fi
    if [ $# -eq 0 ]
    then
        local len=24
    else
        local len=$1
    fi
    openssl rand -base64 $len
}


# ------------------ 翻墙 ---------------------------
if [ "$(uname)" != "Darwin" ]; then
    # 非mac
    if [ -f $server_script/fanqiang/fanqiang.sh  ]; then
        . $server_script/fanqiang/fanqiang.sh
    else
        echo "$server_script/fanqiang/fanqiang.sh 找不到"  >&2
        echo "无法加载翻墙客户端、翻墙服务器的alias脚本"   >&2
    fi
fi


# dropbox loader
# 安装使用教程：https://linux.cn/article-6814-1.html
# 此软件使用前需先翻墙
# alias dbx='$server_script/dropbox_uploader.sh'
alias dbx='python2 $server_script/dropbox/dropbox.py'

# -------------------------------------------------------------------------
# sshfs
# 挂载
alias sshfs='sshfs -o allow_other,default_permissions,reconnect'

# 卸挂载
usshfs()
{
    if [ "$1" = '-h' ] || [ "$1" = '--help' ] || [ "$1" = 'help' ]; then
        echo "usshfs <mounted_path>: safe unmount when the dir is not used now"
        echo "usshfs -f <mounted_path>: forced unmount"
    elif [ "$1" = '-f' ]; then
        shift
        sudo umount -l $@
    else
        fusermount -u $@
    fi
}

# 列出目前mount的所有磁盘
alias sshfs_jch='jch sshfs'

# 实用小工具
timezone()
{
    local source_TZ="$1"
    local source_time="$2"
    if [ $# -eq 3 ]; then
        local target_TZ="$3"
    else
        local target_TZ='Asia/Shanghai'
    fi
    local target_time="$(TZ="$target_TZ" date -d @$(TZ="$source_TZ" date -d  "$source_time" +%s) '+%F %T 周%w')"
    target_time="$(echo $target_time | sed 's/周0/周日/g')"
    echo $target_TZ $target_time
}


